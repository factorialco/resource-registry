# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sinatra-contrib` gem.
# Please instead update this file by running `bin/tapioca gem sinatra-contrib`.


# source://sinatra-contrib//lib/sinatra/contrib/version.rb#3
module Sinatra
  class << self
    # source://sinatra/3.2.0/lib/sinatra/base.rb#2107
    def helpers(*extensions, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2095
    def new(base = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2102
    def register(*extensions, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2112
    def use(*args, &block); end
  end
end

class Sinatra::Application < ::Sinatra::Base
  include ::Sinatra::EngineTracking
  include ::Sinatra::Capture
  include ::Sinatra::ContentFor
  include ::Sinatra::Cookies
  include ::Sinatra::LinkHeader
  include ::Sinatra::Streaming
  include ::Sinatra::RequiredParams
  include ::Sinatra::RespondWith::Helpers
  include ::Sinatra::HamlHelpers
  extend ::Sinatra::Contrib::Common
  extend ::Sinatra::ConfigFile
  extend ::Sinatra::MultiRoute
  extend ::Sinatra::Namespace
  extend ::Sinatra::Namespace::SharedMethods
  extend ::Sinatra::Namespace::BaseMethods
  extend ::Sinatra::RespondWith
  extend ::Sinatra::Reloader
  extend ::Sinatra::Reloader::BaseMethods
  extend ::Sinatra::Reloader::ExtensionMethods

  class << self
    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def app_file; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def app_file=(val); end

    def app_file?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def environments; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def environments=(val); end

    def environments?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def ext_map; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1364
    def ext_map=(val); end

    def ext_map?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2030
    def logging; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def logging=(val); end

    def logging?; end
    def method_override; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def method_override=(val); end

    def method_override?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#2035
    def register(*extensions, &block); end

    # source://sinatra-contrib//lib/sinatra/reloader.rb#236
    def reload_templates; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def reload_templates=(val); end

    def reload_templates?; end

    # source://sinatra-contrib//lib/sinatra/reloader.rb#235
    def reloader; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def reloader=(val); end

    def reloader?; end

    # source://sinatra/3.2.0/lib/sinatra/main.rb#36
    def run; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def run=(val); end

    def run?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def template_engines; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1364
    def template_engines=(val); end

    def template_engines?; end
  end
end

class Sinatra::Base
  include ::Sinatra::JSON

  # source://sinatra/3.2.0/lib/sinatra/base.rb#974
  def initialize(app = T.unsafe(nil), **_kwargs); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def app; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def app=(_arg0); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#983
  def call(env); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#987
  def call!(env); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def env; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def env=(_arg0); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1034
  def forward; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1021
  def halt(*response); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def params; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def params=(_arg0); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1029
  def pass(&block); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def request; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def request=(_arg0); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def response; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#971
  def response=(_arg0); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1015
  def settings; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#972
  def template_cache; end

  private

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1170
  def dispatch!; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1262
  def dump_errors!(boom); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1243
  def error_block!(key, *block_params); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1048
  def filter!(type, base = T.unsafe(nil), &block); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1893
  def force_encoding(*args); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1197
  def handle_exception!(boom); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1154
  def invoke(&block); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1091
  def process_route(pattern, conditions, block = T.unsafe(nil), values = T.unsafe(nil)); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1057
  def route!(base = T.unsafe(nil), pass_block = T.unsafe(nil)); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1082
  def route_eval; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1129
  def route_missing; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#1137
  def static!(options = T.unsafe(nil)); end

  class << self
    def absolute_redirects; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def absolute_redirects=(val); end

    def absolute_redirects?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def add_charset; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def add_charset=(val); end

    def add_charset?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1481
    def add_filter(type, path = T.unsafe(nil), **options, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1476
    def after(path = T.unsafe(nil), **options, &block); end

    def app_file; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def app_file=(val); end

    def app_file?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1469
    def before(path = T.unsafe(nil), **options, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1936
    def bind; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def bind=(val); end

    def bind?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1636
    def build(app); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1644
    def call(env); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1650
    def caller_files; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1294
    def callers_to_ignore; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1495
    def condition(name = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1562
    def configure(*envs); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def default_content_type; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def default_content_type=(val); end

    def default_content_type?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def default_encoding; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def default_encoding=(val); end

    def default_encoding?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1526
    def delete(path, opts = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1556
    def development?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1382
    def disable(*opts); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1901
    def dump_errors; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def dump_errors=(val); end

    def dump_errors?; end
    def empty_path_info; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def empty_path_info=(val); end

    def empty_path_info?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1377
    def enable(*opts); end

    def environment; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def environment=(val); end

    def environment?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1389
    def error(*codes, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1292
    def errors; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1317
    def extensions; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1292
    def filters; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1880
    def force_encoding(data, encoding = T.unsafe(nil)); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1514
    def get(path, opts = T.unsafe(nil), &block); end

    def handler_name; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def handler_name=(val); end

    def handler_name?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1528
    def head(path, opts = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1540
    def helpers(*extensions, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1415
    def inline_templates=(file = T.unsafe(nil)); end

    def json_content_type; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def json_content_type=(val); end

    def json_content_type?; end

    # source://sinatra-contrib//lib/sinatra/json.rb#122
    def json_encoder; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def json_encoder=(val); end

    def json_encoder?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1409
    def layout(name = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1534
    def link(path, opts = T.unsafe(nil), &block); end

    def lock; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def lock=(val); end

    def lock?; end
    def logging; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def logging=(val); end

    def logging?; end
    def method_override; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def method_override=(val); end

    def method_override?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def methodoverride=(val); end

    def methodoverride?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1326
    def middleware; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1448
    def mime_type(type, value = T.unsafe(nil)); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1461
    def mime_types(type); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def mustermann_opts; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1364
    def mustermann_opts=(val); end

    def mustermann_opts?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1628
    def new(*args, **_arg1, &block); end

    def new!(*_arg0); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1398
    def not_found(&block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1485
    def on_start(&on_start_callback); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1292
    def on_start_callback; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1489
    def on_stop(&on_stop_callback); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1292
    def on_stop_callback; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1530
    def options(path, opts = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1532
    def patch(path, opts = T.unsafe(nil), &block); end

    def port; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def port=(val); end

    def port?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1524
    def post(path, opts = T.unsafe(nil), &block); end

    def prefixed_redirects; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def prefixed_redirects=(val); end

    def prefixed_redirects?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1557
    def production?; end

    def protection; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def protection=(val); end

    def protection?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1618
    def prototype; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1499
    def public=(value); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1508
    def public_dir; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1504
    def public_dir=(value); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1959
    def public_folder; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def public_folder=(val); end

    def public_folder?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1522
    def put(path, opts = T.unsafe(nil), &block); end

    def quiet; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def quiet=(val); end

    def quiet?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1574
    def quit!; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1900
    def raise_errors; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def raise_errors=(val); end

    def raise_errors?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1547
    def register(*extensions, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1955
    def reload_templates; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def reload_templates=(val); end

    def reload_templates?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1300
    def reset!; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1953
    def root; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def root=(val); end

    def root?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1292
    def routes; end

    def run; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1591
    def run!(options = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def run=(val); end

    def run?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1613
    def running?; end

    def running_server; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def running_server=(val); end

    def running_server?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def server; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def server=(val); end

    def server?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def session_secret; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def session_secret=(val); end

    def session_secret?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1356
    def session_store; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def session_store=(val); end

    def session_store?; end
    def sessions; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def sessions=(val); end

    def sessions?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1336
    def set(option, value = T.unsafe(nil), ignore_setter = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1010
    def settings; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1902
    def show_exceptions; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def show_exceptions=(val); end

    def show_exceptions?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1591
    def start!(options = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1960
    def static; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def static=(val); end

    def static?; end
    def static_cache_control; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def static_cache_control=(val); end

    def static_cache_control?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1574
    def stop!; end

    def strict_paths; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def strict_paths=(val); end

    def strict_paths?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1403
    def template(name, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1292
    def templates; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1558
    def test?; end

    def threaded; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def threaded=(val); end

    def threaded?; end
    def traps; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def traps=(val); end

    def traps?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1536
    def unlink(path, opts = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1567
    def use(middleware, *args, **_arg2, &block); end

    def use_code; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def use_code=(val); end

    def use_code?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1954
    def views; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def views=(val); end

    def views?; end
    def x_cascade; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1355
    def x_cascade=(val); end

    def x_cascade?; end

    private

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1710
    def agent(pattern); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1871
    def cleaned_caller(keep = T.unsafe(nil)); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1781
    def compile(path, route_mustermann_opts = T.unsafe(nil)); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1761
    def compile!(verb, path, block, **options); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1696
    def define_singleton(name, content = T.unsafe(nil)); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1754
    def generate_method(method_name, &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1704
    def host_name(pattern); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1850
    def inherited(subclass); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1750
    def invoke_hook(name, *args); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1723
    def provides(*types); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1742
    def route(verb, path, options = T.unsafe(nil), &block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1812
    def setup_common_logger(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1816
    def setup_custom_logger(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1785
    def setup_default_middleware(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1799
    def setup_logging(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1795
    def setup_middleware(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1808
    def setup_null_logger(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1824
    def setup_protection(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1841
    def setup_sessions(builder); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1680
    def setup_traps; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1657
    def start_server(handler, server_settings, handler_name); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1676
    def suppress_messages?; end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1857
    def synchronize(&block); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1710
    def user_agent(pattern); end

    # source://sinatra/3.2.0/lib/sinatra/base.rb#1866
    def warn_for_deprecation(message); end
  end
end

# = Sinatra::Capture
#
# Extension that enables blocks inside other extensions.
# It currently works for erb, slim and haml.
# Enables mixing of different template languages.
#
# Example:
#
#    # in hello_world.erb
#
#    Say
#    <% a = capture do %>World<% end %>
#    Hello <%= a %>!
#
#    # in hello_world.slim
#
#    | Say
#    - a = capture do
#      | World
#    |  Hello #{a}!
#
#    # in hello_world.haml
#
#    Say
#    - a = capture do
#      World
#      Hello #{a.strip}!
#
#
# You can also use nested blocks.
#
# Example
#
#     # in hello_world.erb
#
#     Say
#     <% a = capture do %>
#       <% b = capture do %>World<% end %>
#         <%= b %>!
#     <% end %>
#     Hello <%= a.strip %>
#
#
# The main advantage of capture is mixing of different template engines.
#
# Example
#
#    # in mix_me_up.slim
#
#    - two = capture do
#      - erb "<%= 1 + 1 %>"
#    | 1 + 1 = #{two}
#
# == Usage
#
# === Classic Application
#
# In a classic application simply require the helpers, and start using them:
#
#     require "sinatra"
#     require "sinatra/capture"
#
#     # The rest of your classic application code goes here...
#
# === Modular Application
#
# In a modular application you need to require the helpers, and then tell
# the application you will use them:
#
#     require "sinatra/base"
#     require "sinatra/capture"
#
#     class MyApp < Sinatra::Base
#       helpers Sinatra::Capture
#
#       # The rest of your modular application code goes here...
#     end
#
# source://sinatra-contrib//lib/sinatra/capture.rb#84
module Sinatra::Capture
  include ::Sinatra::EngineTracking

  # source://sinatra-contrib//lib/sinatra/capture.rb#87
  def capture(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/capture.rb#106
  def capture_later(&block); end
end

# = Sinatra::ConfigFile
#
# <tt>Sinatra::ConfigFile</tt> is an extension that allows you to load the
# application's configuration from YAML files.  It automatically detects if
# the files contain specific environment settings and it will use those
# corresponding to the current one.
#
# You can access those options through +settings+ within the application. If
# you try to get the value for a setting that hasn't been defined in the
# config file for the current environment, you will get whatever it was set
# to in the application.
#
# == Usage
#
# Once you have written your configurations to a YAML file you can tell the
# extension to load them.  See below for more information about how these
# files are interpreted.
#
# For the examples, lets assume the following config.yml file:
#
#     greeting: Welcome to my file configurable application
#
# === Classic Application
#
#     require "sinatra"
#     require "sinatra/config_file"
#
#     config_file 'path/to/config.yml'
#
#     get '/' do
#       @greeting = settings.greeting
#       haml :index
#     end
#
#     # The rest of your classic application code goes here...
#
# === Modular Application
#
#     require "sinatra/base"
#     require "sinatra/config_file"
#
#     class MyApp < Sinatra::Base
#       register Sinatra::ConfigFile
#
#       config_file 'path/to/config.yml'
#
#       get '/' do
#         @greeting = settings.greeting
#         haml :index
#       end
#
#       # The rest of your modular application code goes here...
#     end
#
# === Config File Format
#
# In its most simple form this file is just a key-value list:
#
#     foo: bar
#     something: 42
#     nested:
#       a: 1
#       b: 2
#
# But it also can provide specific environment configuration.  There are two
# ways to do that: at the file level and at the settings level.
#
# At the settings level (e.g. in 'path/to/config.yml'):
#
#     development:
#       foo: development
#       bar: bar
#     test:
#       foo: test
#       bar: bar
#     production:
#       foo: production
#       bar: bar
#
# Or at the file level:
#
#     foo:
#       development: development
#       test: test
#       production: production
#     bar: bar
#
# In either case, <tt>settings.foo</tt> will return the environment name, and
# <tt>settings.bar</tt> will return <tt>"bar"</tt>.
#
# If you wish to provide defaults that may be shared among all the
# environments, this can be done by using a YAML alias, and then overwriting
# values in environments where appropriate:
#
#     default: &common_settings
#       foo: 'foo'
#       bar: 'bar'
#
#     production:
#       <<: *common_settings
#       bar: 'baz' # override the default value
#
# source://sinatra-contrib//lib/sinatra/config_file.rb#108
module Sinatra::ConfigFile
  # Loads the configuration from the YAML files whose +paths+ are passed as
  # arguments, filtering the settings for the current environment.  Note that
  # these +paths+ can actually be globs.
  #
  # source://sinatra-contrib//lib/sinatra/config_file.rb#118
  def config_file(*paths); end

  private

  # Given a +hash+ containing application configuration it returns
  # settings applicable to the current environment. Note: It gives
  # precedence to environment settings defined at the root-level.
  #
  # source://sinatra-contrib//lib/sinatra/config_file.rb#145
  def config_for_env(hash); end

  # Returns true if supplied with a hash that has any recognized
  # +environments+ in its root keys.
  #
  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/config_file.rb#165
  def environment_keys?(hash); end

  # Given a +hash+ returns the settings corresponding to the current
  # environment.
  #
  # source://sinatra-contrib//lib/sinatra/config_file.rb#159
  def from_environment_key(hash); end

  class << self
    # When the extension is registered sets the +environments+ setting to the
    # traditional environments: development, test and production.
    #
    # source://sinatra-contrib//lib/sinatra/config_file.rb#111
    def registered(base); end
  end
end

# source://sinatra-contrib//lib/sinatra/config_file.rb#134
class Sinatra::ConfigFile::UnsupportedConfigType < ::StandardError
  # source://sinatra-contrib//lib/sinatra/config_file.rb#135
  def message; end
end

# = Sinatra::ContentFor
#
# <tt>Sinatra::ContentFor</tt> is a set of helpers that allows you to capture
# blocks inside views to be rendered later during the request. The most
# common use is to populate different parts of your layout from your view.
#
# The currently supported engines are: Erb, Erubi, Haml and Slim.
#
# == Usage
#
# You call +content_for+, generally from a view, to capture a block of markup
# giving it an identifier:
#
#     # index.erb
#     <% content_for :some_key do %>
#       <chunk of="html">...</chunk>
#     <% end %>
#
# Then, you call +yield_content+ with that identifier, generally from a
# layout, to render the captured block:
#
#     # layout.erb
#     <%= yield_content :some_key %>
#
# If you have provided +yield_content+ with a block and no content for the
# specified key is found, it will render the results of the block provided
# to yield_content.
#
#     # layout.erb
#     <% yield_content :some_key_with_no_content do %>
#       <chunk of="default html">...</chunk>
#     <% end %>
#
# === Classic Application
#
# To use the helpers in a classic application all you need to do is require
# them:
#
#     require "sinatra"
#     require "sinatra/content_for"
#
#     # Your classic application code goes here...
#
# === Modular Application
#
# To use the helpers in a modular application you need to require them, and
# then, tell the application you will use them:
#
#     require "sinatra/base"
#     require "sinatra/content_for"
#
#     class MyApp < Sinatra::Base
#       helpers Sinatra::ContentFor
#
#       # The rest of your modular application code goes here...
#     end
#
# == And How Is This Useful?
#
# For example, some of your views might need a few javascript tags and
# stylesheets, but you don't want to force this files in all your pages.
# Then you can put <tt><%= yield_content :scripts_and_styles %></tt> on your
# layout, inside the <head> tag, and each view can call <tt>content_for</tt>
# setting the appropriate set of tags that should be added to the layout.
#
# == Limitations
#
# Due to the rendering process limitation using <tt><%= yield_content %></tt>
# from within nested templates do not work above the <tt><%= yield %> statement.
# For more details https://github.com/sinatra/sinatra-contrib/issues/140#issuecomment-48831668
#
#     # app.rb
#     get '/' do
#       erb :body, :layout => :layout do
#         erb :foobar
#       end
#     end
#
#     # foobar.erb
#     <% content_for :one do %>
#       <script>
#         alert('one');
#       </script>
#     <% end %>
#     <% content_for :two do %>
#       <script>
#         alert('two');
#       </script>
#     <% end %>
#
# Using <tt><%= yield_content %></tt> before <tt><%= yield %></tt> will cause only the second
# alert to display:
#
#     # body.erb
#     # Display only second alert
#     <%= yield_content :one %>
#     <%= yield %>
#     <%= yield_content :two %>
#
#     # body.erb
#     # Display both alerts
#     <%= yield %>
#     <%= yield_content :one %>
#     <%= yield_content :two %>
#
# source://sinatra-contrib//lib/sinatra/content_for.rb#112
module Sinatra::ContentFor
  include ::Sinatra::EngineTracking
  include ::Sinatra::Capture

  # Unset a named block of content. For example:
  #
  #    <% clear_content_for :head %>
  #
  # source://sinatra-contrib//lib/sinatra/content_for.rb#155
  def clear_content_for(key); end

  # Capture a block of content to be rendered later. For example:
  #
  #     <% content_for :head do %>
  #       <script type="text/javascript" src="/foo.js"></script>
  #     <% end %>
  #
  # You can also pass an immediate value instead of a block:
  #
  #     <% content_for :title, "foo" %>
  #
  # You can call +content_for+ multiple times with the same key
  # (in the example +:head+), and when you render the blocks for
  # that key all of them will be rendered, in the same order you
  # captured them.
  #
  # Your blocks can also receive values, which are passed to them
  # by <tt>yield_content</tt>
  #
  # source://sinatra-contrib//lib/sinatra/content_for.rb#132
  def content_for(key, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Check if a block of content with the given key was defined. For
  # example:
  #
  #     <% content_for :head do %>
  #       <script type="text/javascript" src="/foo.js"></script>
  #     <% end %>
  #
  #     <% if content_for? :head %>
  #       <span>content "head" was defined.</span>
  #     <% end %>
  #
  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/content_for.rb#148
  def content_for?(key); end

  # Render the captured blocks for a given key. For example:
  #
  #     <head>
  #       <title>Example</title>
  #       <%= yield_content :head %>
  #     </head>
  #
  # Would render everything you declared with <tt>content_for
  # :head</tt> before closing the <tt><head></tt> tag.
  #
  # You can also pass values to the content blocks by passing them
  # as arguments after the key:
  #
  #     <%= yield_content :head, 1, 2 %>
  #
  # Would pass <tt>1</tt> and <tt>2</tt> to all the blocks registered
  # for <tt>:head</tt>.
  #
  # source://sinatra-contrib//lib/sinatra/content_for.rb#176
  def yield_content(key, *args, &block); end

  private

  # source://sinatra-contrib//lib/sinatra/content_for.rb#191
  def content_blocks; end
end

# source://sinatra-contrib//lib/sinatra/contrib/version.rb#4
module Sinatra::Contrib
  extend ::Sinatra::Contrib::Loader

  class << self
    # source://sinatra-contrib//lib/sinatra/contrib/setup.rb#49
    def registered(base); end
  end
end

# source://sinatra-contrib//lib/sinatra/contrib/setup.rb#42
module Sinatra::Contrib::All
  class << self
    # source://sinatra-contrib//lib/sinatra/contrib/setup.rb#43
    def registered(base); end
  end
end

# Common middleware that doesn't bring run time overhead if not used
# or breaks if external dependencies are missing. Will extend
# Sinatra::Application by default.
#
# source://sinatra-contrib//lib/sinatra/contrib/setup.rb#34
module Sinatra::Contrib::Common
  extend ::Sinatra::Contrib::Loader
end

# Other extensions you don't want to be loaded unless needed.
#
# source://sinatra-contrib//lib/sinatra/contrib/setup.rb#38
module Sinatra::Contrib::Custom
  extend ::Sinatra::Contrib::Loader
end

# source://sinatra-contrib//lib/sinatra/contrib/setup.rb#8
module Sinatra::Contrib::Loader
  # source://sinatra-contrib//lib/sinatra/contrib/setup.rb#21
  def autoload(name, path, method = T.unsafe(nil)); end

  # source://sinatra-contrib//lib/sinatra/contrib/setup.rb#9
  def extensions; end

  # source://sinatra-contrib//lib/sinatra/contrib/setup.rb#17
  def helpers(name, path); end

  # source://sinatra-contrib//lib/sinatra/contrib/setup.rb#13
  def register(name, path); end

  # source://sinatra-contrib//lib/sinatra/contrib/setup.rb#26
  def registered(base); end
end

# source://sinatra-contrib//lib/sinatra/contrib/version.rb#5
Sinatra::Contrib::VERSION = T.let(T.unsafe(nil), String)

# = Sinatra::Cookies
#
# Easy way to deal with cookies
#
# == Usage
#
# Allows you to read cookies:
#
#   get '/' do
#     "value: #{cookies[:something]}"
#   end
#
# And of course to write cookies:
#
#   get '/set' do
#     cookies[:something] = 'foobar'
#     redirect to('/')
#   end
#
# And generally behaves like a hash:
#
#   get '/demo' do
#     cookies.merge! 'foo' => 'bar', 'bar' => 'baz'
#     cookies.keep_if { |key, value| key.start_with? 'b' }
#     foo, bar = cookies.values_at 'foo', 'bar'
#     "size: #{cookies.length}"
#   end
#
# === Classic Application
#
# In a classic application simply require the helpers, and start using them:
#
#     require "sinatra"
#     require "sinatra/cookies"
#
#     # The rest of your classic application code goes here...
#
# === Modular Application
#
# In a modular application you need to require the helpers, and then tell
# the application to use them:
#
#     require "sinatra/base"
#     require "sinatra/cookies"
#
#     class MyApp < Sinatra::Base
#       helpers Sinatra::Cookies
#
#       # The rest of your modular application code goes here...
#     end
#
# source://sinatra-contrib//lib/sinatra/cookies.rb#57
module Sinatra::Cookies
  # source://sinatra-contrib//lib/sinatra/cookies.rb#339
  def cookies; end
end

# source://sinatra-contrib//lib/sinatra/cookies.rb#58
class Sinatra::Cookies::Jar
  include ::Enumerable

  # @return [Jar] a new instance of Jar
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#62
  def initialize(app); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#81
  def ==(other); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#85
  def [](key); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#89
  def []=(key, value); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#94
  def assoc(key); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#99
  def clear; end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#103
  def compare_by_identity?; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#107
  def default; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#107
  def default_proc; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#113
  def delete(key); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#119
  def delete_if; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#126
  def each(&block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#132
  def each_key(&block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#126
  def each_pair(&block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#140
  def each_value(&block); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#146
  def empty?; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#150
  def fetch(key, &block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#157
  def flatten; end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#162
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#166
  def has_value?(value); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#170
  def hash; end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#162
  def include?(key); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#177
  def inspect; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#182
  def invert; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#187
  def keep_if; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#193
  def key(value); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#162
  def key?(key); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#199
  def keys; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#203
  def length; end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#162
  def member?(key); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#207
  def merge(other, &block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#211
  def merge!(other); end

  # Returns the value of attribute options.
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#60
  def options; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#221
  def rassoc(value); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#225
  def rehash; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#231
  def reject(&block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#119
  def reject!; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#239
  def replace(other); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#244
  def select(&block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#187
  def select!; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#252
  def set(key, options = T.unsafe(nil)); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#256
  def shift; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#203
  def size; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#265
  def sort(&block); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#89
  def store(key, value); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#276
  def to_a; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#272
  def to_hash; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#280
  def to_s; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#211
  def update(other); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/cookies.rb#166
  def value?(value); end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#287
  def values; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#291
  def values_at(*list); end

  private

  # source://sinatra-contrib//lib/sinatra/cookies.rb#301
  def deleted; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#311
  def parse_response; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#334
  def request_cookies; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#306
  def response_cookies; end

  # source://sinatra-contrib//lib/sinatra/cookies.rb#297
  def warn(message); end
end

# Adds methods like `haml?` that allow helper methods to check whether they
# are called from within a template.
#
# source://sinatra-contrib//lib/sinatra/engine_tracking.rb#8
module Sinatra::EngineTracking
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#80
  def initialize(*_arg0); end

  # @return [Boolean] Returns true if current engine is `:builder`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#41
  def builder?; end

  # Returns the value of attribute current_engine.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#9
  def current_engine; end

  # @return [Boolean] Returns true if current engine is `:erb`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#12
  def erb?; end

  # Returns true if the current engine is `:erubi`, or `Tilt[:erb]` is set
  # to Tilt::ErubiTemplate.
  #
  # @return [Boolean] Returns true if current engine is `:erubi`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#20
  def erubi?; end

  # @return [Boolean] Returns true if current engine is `:haml`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#26
  def haml?; end

  # @return [Boolean] Returns true if current engine is `:liquid`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#46
  def liquid?; end

  # @return [Boolean] Returns true if current engine is `:markaby`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#61
  def markaby?; end

  # @return [Boolean] Returns true if current engine is `:markdown`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#51
  def markdown?; end

  # @return [Boolean] Returns true if current engine is `:nokogiri`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#66
  def nokogiri?; end

  # @return [Boolean] Returns true if current engine is `:rdoc`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#56
  def rdoc?; end

  # @return [Boolean] Returns true if current engine is `:ruby`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#76
  def ruby?; end

  # @return [Boolean] Returns true if current engine is `:sass`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#31
  def sass?; end

  # @return [Boolean] Returns true if current engine is `:scss`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#36
  def scss?; end

  # @return [Boolean] Returns true if current engine is `:slim`.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#71
  def slim?; end

  # @param engine [Symbol, String] Name of Engine to shift to.
  #
  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#86
  def with_engine(engine); end

  private

  # source://sinatra-contrib//lib/sinatra/engine_tracking.rb#96
  def render(engine, *_arg1); end
end

# = Sinatra::Extension
#
# <tt>Sinatra::Extension</tt> is a mixin that provides some syntactic sugar
# for your extensions. It allows you to call almost any
# <tt>Sinatra::Base</tt> method directly inside your extension
# module. This means you can use +get+ to define a route, +before+
# to define a before filter, +set+ to define a setting and so on.
#
# Is important to be aware that this mixin remembers the method calls you
# make, and then, when your extension is registered, replays them on the
# Sinatra application that has been extended.  In order to do that, it
# defines a <tt>registered</tt> method, so, if your extension defines one
# too, remember to call +super+.
#
# == Usage
#
# Just require the mixin and extend your extension with it:
#
#     require 'sinatra/extension'
#
#     module MyExtension
#       extend Sinatra::Extension
#
#       # set some settings for development
#       configure :development do
#         set :reload_stuff, true
#       end
#
#       # define a route
#       get '/' do
#         'Hello World'
#       end
#
#       # The rest of your extension code goes here...
#     end
#
# You can also create an extension with the +new+ method:
#
#     MyExtension = Sinatra::Extension.new do
#       # Your extension code goes here...
#     end
#
# This is useful when you just want to pass a block to
# <tt>Sinatra::Base.register</tt>.
#
# source://sinatra-contrib//lib/sinatra/extension.rb#50
module Sinatra::Extension
  # source://sinatra-contrib//lib/sinatra/extension.rb#61
  def configure(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/extension.rb#65
  def registered(base = T.unsafe(nil), &block); end

  # source://sinatra-contrib//lib/sinatra/extension.rb#57
  def settings; end

  private

  # source://sinatra-contrib//lib/sinatra/extension.rb#83
  def method_missing(method, *args, &block); end

  # source://sinatra-contrib//lib/sinatra/extension.rb#71
  def record(method, *args, &block); end

  # source://sinatra-contrib//lib/sinatra/extension.rb#79
  def recorded_methods; end

  # source://sinatra-contrib//lib/sinatra/extension.rb#75
  def replay(object); end

  class << self
    # source://sinatra-contrib//lib/sinatra/extension.rb#51
    def new(&block); end
  end
end

# source://sinatra-contrib//lib/sinatra/extension.rb#90
class Sinatra::Extension::DontCall < ::BasicObject
  # @return [DontCall] a new instance of DontCall
  #
  # source://sinatra-contrib//lib/sinatra/extension.rb#91
  def initialize(method); end

  # source://sinatra-contrib//lib/sinatra/extension.rb#93
  def inspect; end

  # source://sinatra-contrib//lib/sinatra/extension.rb#92
  def method_missing(*_arg0); end
end

# = Sinatra::HamlHelpers
#
# This extension provides some of the helper methods that existed in Haml 5
# but were removed in Haml 6. To use this in your app, just +register+ it:
#
#   require 'sinatra/base'
#   require 'sinatra/haml_helpers'
#
#   class Application < Sinatra::Base
#     register Sinatra::HamlHelpers
#
#     # now you can use the helpers in your views
#     get '/' do
#       haml_code = <<~HAML
#         %p
#           != surround "(", ")" do
#             %a{ href: "https://example.org/" } example.org
#       HAML
#       haml haml_code
#     end
#   end
#
# source://sinatra-contrib//lib/sinatra/haml_helpers.rb#29
module Sinatra::HamlHelpers
  include ::Sinatra::EngineTracking
  include ::Sinatra::Capture

  # source://sinatra-contrib//lib/sinatra/haml_helpers.rb#44
  def _capture_haml(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/haml_helpers.rb#36
  def precede(str, &block); end

  # source://sinatra-contrib//lib/sinatra/haml_helpers.rb#40
  def succeed(str, &block); end

  # source://sinatra-contrib//lib/sinatra/haml_helpers.rb#32
  def surround(front, back = T.unsafe(nil), &block); end
end

# = Sinatra::JSON
#
# <tt>Sinatra::JSON</tt> adds a helper method, called +json+, for (obviously)
# json generation.
#
# == Usage
#
# === Classic Application
#
# In a classic application simply require the helper, and start using it:
#
#     require "sinatra"
#     require "sinatra/json"
#
#     # define a route that uses the helper
#     get '/' do
#       json :foo => 'bar'
#     end
#
#     # The rest of your classic application code goes here...
#
# === Modular Application
#
# In a modular application you need to require the helper, and then tell the
# application you will use it:
#
#     require "sinatra/base"
#     require "sinatra/json"
#
#     class MyApp < Sinatra::Base
#
#       # define a route that uses the helper
#       get '/' do
#         json :foo => 'bar'
#       end
#
#       # The rest of your modular application code goes here...
#     end
#
# === Encoders
#
# By default it will try to call +to_json+ on the object, but if it doesn't
# respond to that message, it will use its own rather simple encoder.  You can
# easily change that anyways. To use +JSON+, simply require it:
#
#   require 'json'
#
# The same goes for <tt>Yajl::Encoder</tt>:
#
#   require 'yajl'
#
# For other encoders, besides requiring them, you need to define the
# <tt>:json_encoder</tt> setting.  For instance, for the +Whatever+ encoder:
#
#   require 'whatever'
#   set :json_encoder, Whatever
#
# To force +json+ to simply call +to_json+ on the object:
#
#   set :json_encoder, :to_json
#
# Actually, it can call any method:
#
#   set :json_encoder, :my_fancy_json_method
#
# === Content-Type
#
# It will automatically set the content type to "application/json".  As
# usual, you can easily change that, with the <tt>:json_content_type</tt>
# setting:
#
#   set :json_content_type, :js
#
# === Overriding the Encoder and the Content-Type
#
# The +json+ helper will also take two options <tt>:encoder</tt> and
# <tt>:content_type</tt>.  The values of this options are the same as the
# <tt>:json_encoder</tt> and <tt>:json_content_type</tt> settings,
# respectively.  You can also pass those to the json method:
#
#   get '/'  do
#     json({:foo => 'bar'}, :encoder => :to_json, :content_type => :js)
#   end
#
# source://sinatra-contrib//lib/sinatra/json.rb#90
module Sinatra::JSON
  # source://sinatra-contrib//lib/sinatra/json.rb#97
  def json(object, options = T.unsafe(nil)); end

  private

  # source://sinatra-contrib//lib/sinatra/json.rb#104
  def resolve_content_type(options = T.unsafe(nil)); end

  # source://sinatra-contrib//lib/sinatra/json.rb#108
  def resolve_encoder(options = T.unsafe(nil)); end

  # source://sinatra-contrib//lib/sinatra/json.rb#112
  def resolve_encoder_action(object, encoder); end

  class << self
    # source://sinatra-contrib//lib/sinatra/json.rb#92
    def encode(object); end
  end
end

# = Sinatra::LinkHeader
#
# <tt>Sinatra::LinkHeader</tt> adds a set of helper methods to generate link
# HTML tags and their corresponding Link HTTP headers.
#
# == Usage
#
# Once you had set up the helpers in your application (see below), you will
# be able to call the following methods from inside your route handlers,
# filters and templates:
#
# +prefetch+::
#     Sets the Link HTTP headers and returns HTML tags to prefetch the given
#     resources.
#
# +stylesheet+::
#     Sets the Link HTTP headers and returns HTML tags to use the given
#     stylesheets.
#
# +link+::
#     Sets the Link HTTP headers and returns the corresponding HTML tags
#     for the given resources.
#
# +link_headers+::
#     Returns the corresponding HTML tags for the current Link HTTP headers.
#
# === Classic Application
#
# In a classic application simply require the helpers, and start using them:
#
#     require "sinatra"
#     require "sinatra/link_header"
#
#     # The rest of your classic application code goes here...
#
# === Modular Application
#
# In a modular application you need to require the helpers, and then tell
# the application you will use them:
#
#     require "sinatra/base"
#     require "sinatra/link_header"
#
#     class MyApp < Sinatra::Base
#       helpers Sinatra::LinkHeader
#
#       # The rest of your modular application code goes here...
#     end
#
# source://sinatra-contrib//lib/sinatra/link_header.rb#53
module Sinatra::LinkHeader
  # Sets Link HTTP header and returns corresponding HTML tags.
  #
  # Example:
  #
  #   # Sets header:
  #   #   Link: </foo>; rel="next"
  #   # Returns String:
  #   #   '<link href="/foo" rel="next" />'
  #   link '/foo', :rel => :next
  #
  #   # Multiple URLs
  #   link :stylesheet, '/a.css', '/b.css'
  #
  # source://sinatra-contrib//lib/sinatra/link_header.rb#83
  def link(*urls); end

  # Takes the current value of th Link header(s) and generates HTML tags
  # from it.
  #
  # Example:
  #
  #   get '/' do
  #     # You can of course use fancy helpers like #link, #stylesheet
  #     # or #prefetch
  #     response["Link"] = '</foo>; rel="next"'
  #     haml :some_page
  #   end
  #
  #   __END__
  #
  #   @@ layout
  #   %head= link_headers
  #   %body= yield
  #
  # source://sinatra-contrib//lib/sinatra/link_header.rb#116
  def link_headers; end

  # Sets Link HTTP header and returns HTML tags for telling the browser to
  # prefetch given resources (only supported by Opera and Firefox at the
  # moment).
  #
  # source://sinatra-contrib//lib/sinatra/link_header.rb#58
  def prefetch(*urls); end

  # Sets Link HTTP header and returns HTML tags for using stylesheets.
  #
  # source://sinatra-contrib//lib/sinatra/link_header.rb#64
  def stylesheet(*urls); end

  class << self
    # source://sinatra-contrib//lib/sinatra/link_header.rb#126
    def registered(_base); end
  end
end

# = Sinatra::MultiRoute
#
# Create multiple routes with one statement.
#
# == Usage
#
# Use this extension to create a handler for multiple routes:
#
#   get '/foo', '/bar' do
#     # ...
#   end
#
# Or for multiple verbs:
#
#   route :get, :post, '/' do
#     # ...
#   end
#
# Or for multiple verbs and multiple routes:
#
#   route :get, :post, ['/foo', '/bar'] do
#     # ...
#   end
#
# Or even for custom verbs:
#
#   route 'LIST', '/' do
#     # ...
#   end
#
# === Classic Application
#
# To use the extension in a classic application all you need to do is require
# it:
#
#     require "sinatra"
#     require "sinatra/multi_route"
#
#     # Your classic application code goes here...
#
# === Modular Application
#
# To use the extension in a modular application you need to require it, and
# then, tell the application you will use it:
#
#     require "sinatra/base"
#     require "sinatra/multi_route"
#
#     class MyApp < Sinatra::Base
#       register Sinatra::MultiRoute
#
#       # The rest of your modular application code goes here...
#     end
#
# source://sinatra-contrib//lib/sinatra/multi_route.rb#60
module Sinatra::MultiRoute
  # source://sinatra-contrib//lib/sinatra/multi_route.rb#62
  def delete(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#63
  def get(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#61
  def head(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#64
  def options(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#65
  def patch(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#66
  def post(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#67
  def put(*args, &block); end

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#69
  def route(*args, &block); end

  private

  # source://sinatra-contrib//lib/sinatra/multi_route.rb#82
  def route_args(args); end
end

# = Sinatra::Namespace
#
# <tt>Sinatra::Namespace</tt> is an extension that adds namespaces to an
# application.  This namespaces will allow you to share a path prefix for the
# routes within the namespace, and define filters, conditions and error
# handlers exclusively for them.  Besides that, you can also register helpers
# and extensions that will be used only within the namespace.
#
# == Usage
#
# Once you have loaded the extension (see below), you can use the +namespace+
# method to define namespaces in your application.
#
# You can define a namespace by a path prefix:
#
#     namespace '/blog' do
#       get { haml :blog }
#       get '/:entry_permalink' do
#         @entry = Entry.find_by_permalink!(params[:entry_permalink])
#         haml :entry
#       end
#
#       # More blog routes...
#     end
#
# by a condition:
#
#     namespace :host_name => 'localhost' do
#       get('/admin/dashboard') { haml :dashboard }
#       get('/admin/login')     { haml :login }
#
#       # More admin routes...
#     end
#
# or both:
#
#     namespace '/admin', :host_name => 'localhost' do
#       get('/dashboard')  { haml :dashboard }
#       get('/login')      { haml :login }
#       post('/login')     { login_user }
#
#       # More admin routes...
#     end
#
# Regex is also accepted:
#
#     namespace /\/posts\/([^\/&?]+)\// do
#       get { haml :blog }
#
#       # More blog routes...
#     end
#
# When you define a filter or an error handler, or register an extension or a
# set of helpers within a namespace, they only affect the routes defined in
# it.  For instance, lets define a before filter to prevent the access of
# unauthorized users to the admin section of the application:
#
#     namespace '/admin' do
#       helpers AdminHelpers
#       before  { authenticate unless request.path_info == '/admin/login' }
#
#       get '/dashboard' do
#         # Only authenticated users can access here...
#         haml :dashboard
#       end
#
#       # More admin routes...
#     end
#
#     get '/' do
#       # Any user can access here...
#       haml :index
#     end
#
# Well, they actually also affect the nested namespaces:
#
#     namespace '/admin' do
#       helpers AdminHelpers
#       before  { authenticate unless request.path_info == '/admin/login' }
#
#       namespace '/users' do
#         get do
#           # Only authenticated users can access here...
#           @users = User.all
#           haml :users
#         end
#
#         # More user admin routes...
#       end
#
#       # More admin routes...
#     end
#
# Redirecting within the namespace can be done using redirect_to:
#
#     namespace '/admin' do
#       get '/foo'  do
#         redirect_to '/bar' # Redirects to /admin/bar
#       end
#
#       get '/foo' do
#         redirect '/bar' # Redirects to /bar
#       end
#     end
#
# === Classic Application Setup
#
# To be able to use namespaces in a classic application all you need to do is
# require the extension:
#
#     require "sinatra"
#     require "sinatra/namespace"
#
#     namespace '/users' do
#     end
#
# === Modular Application Setup
#
# To be able to use namespaces in a modular application all you need to do is
# require the extension, and then, register it:
#
#     require "sinatra/base"
#     require "sinatra/namespace"
#
#     class MyApp < Sinatra::Base
#       register Sinatra::Namespace
#
#       namespace '/users' do
#       end
#     end
#
# === Within an extension
#
# To be able to use namespaces within an extension, you need to first create
# an extension. This includes defining the `registered(app)` method in the
# module.
#
#     require 'sinatra/base' # For creating Sinatra extensions
#     require 'sinatra/namespace' # To create namespaces
#
#     module Zomg # Keep everything under "Zomg" namespace for sanity
#       module Routes # Define a new "Routes" module
#
#         def self.registered(app)
#           # First, register the Namespace extension
#           app.register Sinatra::Namespace
#
#           # This defines an `/api` namespace on the application
#           app.namespace '/api' do
#             get '/users' do
#               # do something with `GET "/api/users"`
#             end
#           end
#
#         end
#       end
#
#       # Lastly, register the extension to use in our app
#       Sinatra.register Routes
#     end
#
# In order to use this extension, is the same as any other Sinatra extension:
#
#     module Zomg
#       # Define our app class, we use modular app for this example
#       class App < Sinatra::Base
#         # this gives us all the namespaces we defined earlier
#         register Routes
#
#         get '/' do
#           "Welcome to my application!"
#         end
#       end
#     end
#
#     Zomg::App.run! # Don't forget to start your app ;)
#
# Phew! That was a mouthful.
#
# I hope that helps you use `Sinatra::Namespace` in every way imaginable!
#
# source://sinatra-contrib//lib/sinatra/namespace.rb#188
module Sinatra::Namespace
  class << self
    # @private
    #
    # source://sinatra-contrib//lib/sinatra/namespace.rb#368
    def extended(base); end

    # source://sinatra-contrib//lib/sinatra/namespace.rb#189
    def new(base, pattern, conditions = T.unsafe(nil), &block); end
  end
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#364
module Sinatra::Namespace::BaseMethods
  include ::Sinatra::Namespace::SharedMethods
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#207
module Sinatra::Namespace::InstanceMethods
  # source://sinatra-contrib//lib/sinatra/namespace.rb#216
  def redirect_to(uri, *args); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#208
  def settings; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#212
  def template_cache; end
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#227
module Sinatra::Namespace::NamespacedMethods
  include ::Sinatra::Namespace::SharedMethods

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def after(*a, &b); end

  # Returns the value of attribute base.
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#229
  def base; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def before(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def delete(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#303
  def disable(*opts); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#299
  def enable(*opts); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#273
  def error(*codes, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#265
  def errors; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def get(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def head(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#243
  def helpers(*extensions, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#257
  def invoke_hook(name, *args); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#314
  def layout(name = T.unsafe(nil), &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#269
  def namespace_errors; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#261
  def not_found(&block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def options(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def patch(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#318
  def pattern; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def post(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#238
  def put(*a, &b); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#248
  def register(*extensions, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#285
  def respond_to(*args); end

  # @raise [ArgumentError]
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#291
  def set(key, value = T.unsafe(nil), &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#307
  def template(name, &block); end

  # Returns the value of attribute templates.
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#229
  def templates; end

  private

  # source://sinatra-contrib//lib/sinatra/namespace.rb#324
  def app; end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#328
  def compile(pattern, conditions, default_pattern = T.unsafe(nil)); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#355
  def method_missing(method, *args, &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#347
  def prefixed(method, pattern = T.unsafe(nil), conditions = T.unsafe(nil), &block); end

  # source://sinatra-contrib//lib/sinatra/namespace.rb#340
  def prefixed_path(a, b); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/namespace.rb#359
  def respond_to?(method, include_private = T.unsafe(nil)); end

  class << self
    # source://sinatra-contrib//lib/sinatra/namespace.rb#237
    def prefixed(*names); end
  end
end

# source://sinatra-contrib//lib/sinatra/namespace.rb#231
Sinatra::Namespace::NamespacedMethods::ALLOWED_ENGINES = T.let(T.unsafe(nil), Array)

# source://sinatra-contrib//lib/sinatra/namespace.rb#221
module Sinatra::Namespace::SharedMethods
  # source://sinatra-contrib//lib/sinatra/namespace.rb#222
  def namespace(pattern, conditions = T.unsafe(nil), &block); end
end

# = Sinatra::Reloader
#
# <b>DEPRECATED:<b> Please consider using an alternative like
# <tt>rerun</tt> or <tt>rack-unreloader</tt> instead.
#
# Extension to reload modified files.  Useful during development,
# since it will automatically require files defining routes, filters,
# error handlers and inline templates, with every incoming request,
# but only if they have been updated.
#
# == Usage
#
# === Classic Application
#
# To enable the reloader in a classic application all you need to do is
# require it:
#
#     require "sinatra"
#     require "sinatra/reloader" if development?
#
#     # Your classic application code goes here...
#
# === Modular Application
#
# To enable the reloader in a modular application all you need to do is
# require it, and then, register it:
#
#     require "sinatra/base"
#     require "sinatra/reloader"
#
#     class MyApp < Sinatra::Base
#       configure :development do
#         register Sinatra::Reloader
#       end
#
#       # Your modular application code goes here...
#     end
#
# == Using the Reloader in Other Environments
#
# By default, the reloader is only enabled for the development
# environment. Similar to registering the reloader in a modular
# application, a classic application requires manually enabling the
# extension for it to be available in a non-development environment.
#
#      require "sinatra"
#      require "sinatra/reloader"
#
#      configure :production do
#        enable :reloader
#      end
#
# == Changing the Reloading Policy
#
# You can refine the reloading policy with +also_reload+ and
# +dont_reload+, to customize which files should, and should not, be
# reloaded, respectively. You can also use +after_reload+ to execute a
# block after any file being reloaded.
#
# === Classic Application
#
# Simply call the methods:
#
#     require "sinatra"
#     require "sinatra/reloader" if development?
#
#     also_reload '/path/to/some/file'
#     dont_reload '/path/to/other/file'
#     after_reload do
#       puts 'reloaded'
#     end
#
#     # Your classic application code goes here...
#
# === Modular Application
#
# Call the methods inside the +configure+ block:
#
#     require "sinatra/base"
#     require "sinatra/reloader"
#
#     class MyApp < Sinatra::Base
#       configure :development do
#         register Sinatra::Reloader
#         also_reload '/path/to/some/file'
#         dont_reload '/path/to/other/file'
#         after_reload do
#           puts 'reloaded'
#         end
#       end
#
#       # Your modular application code goes here...
#     end
#
# source://sinatra-contrib//lib/sinatra/reloader.rb#100
module Sinatra::Reloader
  # source://sinatra-contrib//lib/sinatra/reloader.rb#220
  def after_reload(&block); end

  class << self
    # Reloads the modified files, adding, updating and removing the
    # needed elements.
    #
    # source://sinatra-contrib//lib/sinatra/reloader.rb#247
    def perform(klass); end

    # When the extension is registered it extends the Sinatra application
    # +klass+ with the modules +BaseMethods+ and +ExtensionMethods+ and
    # defines a before filter to +perform+ the reload of the modified files.
    #
    # source://sinatra-contrib//lib/sinatra/reloader.rb#227
    def registered(klass); end
  end
end

# Contains the methods defined in Sinatra::Base that are overridden.
#
# source://sinatra-contrib//lib/sinatra/reloader.rb#272
module Sinatra::Reloader::BaseMethods
  # Does everything Sinatra::Base#add_filter does, but it also tells
  # the +Watcher::List+ for the Sinatra application to watch the defined
  # filter.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#320
  def add_filter(type, path = T.unsafe(nil), **options, &block); end

  # Does everything Sinatra::Base#route does, but it also tells the
  # +Watcher::List+ for the Sinatra application to watch the defined
  # route.
  #
  # Note: We are using #compile! so we don't interfere with extensions
  # changing #route.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#288
  def compile!(verb, path, block, **options); end

  # Does everything Sinatra::Base#error does, but it also tells the
  # +Watcher::List+ for the Sinatra application to watch the defined
  # error handler.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#331
  def error(*codes, &block); end

  # Does everything Sinatra::Base#register does and then registers the
  # reloader in the +subclass+.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#352
  def inherited(subclass); end

  # Does everything Sinatra::Base#inline_templates= does, but it also
  # tells the +Watcher::List+ for the Sinatra application to watch the
  # inline templates in +file+ or the file who made the call to this
  # method.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#302
  def inline_templates=(file = T.unsafe(nil)); end

  # Does everything Sinatra::Base#register does, but it also lets the
  # reloader know that an extension is being registered, because the
  # elements defined in its +registered+ method need a special treatment.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#343
  def register(*extensions, &block); end

  # Protects Sinatra::Base.run! from being called more than once.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#274
  def run!(*args); end

  # Does everything Sinatra::Base#use does, but it also tells the
  # +Watcher::List+ for the Sinatra application to watch the middleware
  # being used.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#311
  def use(middleware, *args, &block); end
end

# Contains the methods that the extension adds to the Sinatra application.
#
# source://sinatra-contrib//lib/sinatra/reloader.rb#360
module Sinatra::Reloader::ExtensionMethods
  # Indicates with a +glob+ which files should be reloaded if they
  # have been modified.  It can be called several times.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#383
  def also_reload(*glob); end

  # Removes the +element+ from the Sinatra application.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#362
  def deactivate(element); end

  # Indicates with a +glob+ which files should not be reloaded even if
  # they have been modified.  It can be called several times.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#389
  def dont_reload(*glob); end

  private

  # attr_reader :register_path warn on -w (private attribute)
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#396
  def register_path; end

  # Indicates whether or not an extension is being registered.
  #
  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#409
  def registering_extension?; end

  # Indicates an extesion is being registered.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#399
  def start_registering_extension; end

  # Indicates the extesion has already been registered.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#404
  def stop_registering_extension; end

  # Builds a Watcher::Element from +type+ and +representation+ and
  # tells the Watcher::List for the current application to watch it
  # in the file located at +path+.
  #
  # If an extension is being registered, it also tells the list to
  # watch it in the file where the extension has been registered.
  # This prevents the duplication of the elements added by the
  # extension in its +registered+ method with every reload.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#421
  def watch_element(path, type, representation = T.unsafe(nil)); end
end

# source://sinatra-contrib//lib/sinatra/reloader.rb#216
Sinatra::Reloader::MUTEX_FOR_PERFORM = T.let(T.unsafe(nil), Thread::Mutex)

# Watches a file so it can tell when it has been updated, and what
# elements does it contain.
#
# source://sinatra-contrib//lib/sinatra/reloader.rb#103
class Sinatra::Reloader::Watcher
  # Creates a new +Watcher+ instance for the file located at +path+.
  #
  # @return [Watcher] a new instance of Watcher
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#175
  def initialize(path); end

  # Returns the value of attribute elements.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#172
  def elements; end

  # Informs that the modifications to the file being watched
  # should be ignored.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#200
  def ignore; end

  # Indicates whether or not the modifications to the file being
  # watched should be ignored.
  #
  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#206
  def ignore?; end

  # Indicates whether or not the file being watched has inline
  # templates.
  #
  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#194
  def inline_templates?; end

  # Returns the value of attribute mtime.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#172
  def mtime; end

  # Returns the value of attribute path.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#172
  def path; end

  # Indicates whether or not the file being watched has been removed.
  #
  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#211
  def removed?; end

  # Updates the mtime of the file being watched.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#188
  def update; end

  # Indicates whether or not the file being watched has been modified.
  #
  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#183
  def updated?; end
end

# Represents an element of a Sinatra application that may need to
# be reloaded.  An element could be:
# * a route
# * a filter
# * an error handler
# * a middleware
# * inline templates
#
# Its +representation+ attribute is there to allow to identify the
# element within an application, that is, to match it with its
# Sinatra's internal representation.
#
# source://sinatra-contrib//lib/sinatra/reloader.rb#115
class Sinatra::Reloader::Watcher::Element < ::Struct; end

# Collection of file +Watcher+ that can be associated with a
# Sinatra application.  That way, we can know which files belong
# to a given application and which files have been modified.  It
# also provides a mechanism to inform a Watcher of the elements
# defined in the file being watched and if its changes should be
# ignored.
#
# source://sinatra-contrib//lib/sinatra/reloader.rb#124
class Sinatra::Reloader::Watcher::List
  # Creates a new +List+ instance.
  #
  # @return [List] a new instance of List
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#133
  def initialize; end

  # Tells the +Watcher+ for the file located at +path+ to ignore
  # the file changes, and adds the +Watcher+ to the +List+, if
  # it isn't already there.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#149
  def ignore(path); end

  # Returns an array with all the watchers in the +List+ that
  # have been updated.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#167
  def updated; end

  # Lets the +Watcher+ for the file located at +path+ know that the
  # +element+ is defined there, and adds the +Watcher+ to the +List+,
  # if it isn't already there.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#142
  def watch(path, element); end

  # Adds a +Watcher+ for the file located at +path+ to the
  # +List+, if it isn't already there.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#155
  def watch_file(path); end

  # Adds a +Watcher+ for the file located at +path+ to the
  # +List+, if it isn't already there.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#155
  def watcher_for(path); end

  # Returns an array with all the watchers in the +List+.
  #
  # source://sinatra-contrib//lib/sinatra/reloader.rb#161
  def watchers; end

  class << self
    # Returns the +List+ for the application +app+.
    #
    # source://sinatra-contrib//lib/sinatra/reloader.rb#128
    def for(app); end
  end
end

# = Sinatra::RequiredParams
#
# Ensure required query parameters
#
# == Usage
#
# Set required query parameter keys in the argument.
# It'll halt with 400 if required keys don't exist.
#
#   get '/simple_keys' do
#     required_params :p1, :p2
#   end
#
# Complicated pattern is also fine.
#
#   get '/complicated_keys' do
#     required_params :p1, :p2 => [:p3, :p4]
#   end
#
# === Classic Application
#
# In a classic application simply require the helpers, and start using them:
#
#     require "sinatra"
#     require "sinatra/required_params"
#
#     # The rest of your classic application code goes here...
#
# === Modular Application
#
# In a modular application you need to require the helpers, and then tell
# the application to use them:
#
#     require "sinatra/base"
#     require "sinatra/required_params"
#
#     class MyApp < Sinatra::Base
#       helpers Sinatra::RequiredParams
#
#       # The rest of your modular application code goes here...
#     end
#
# source://sinatra-contrib//lib/sinatra/required_params.rb#48
module Sinatra::RequiredParams
  # source://sinatra-contrib//lib/sinatra/required_params.rb#49
  def required_params(*keys); end

  private

  # source://sinatra-contrib//lib/sinatra/required_params.rb#55
  def _required_params(p, *keys); end
end

# = Sinatra::RespondWith
#
# These extensions let Sinatra automatically choose what template to render or
# action to perform depending on the request's Accept header.
#
# Example:
#
#   # Without Sinatra::RespondWith
#   get '/' do
#     data = { :name => 'example' }
#     request.accept.each do |type|
#       case type.to_s
#       when 'text/html'
#         halt haml(:index, :locals => data)
#       when 'text/json'
#         halt data.to_json
#       when 'application/atom+xml'
#         halt nokogiri(:'index.atom', :locals => data)
#       when 'application/xml', 'text/xml'
#         halt nokogiri(:'index.xml', :locals => data)
#       when 'text/plain'
#         halt 'just an example'
#       end
#     end
#     error 406
#   end
#
#   # With Sinatra::RespondWith
#   get '/' do
#     respond_with :index, :name => 'example' do |f|
#       f.txt { 'just an example' }
#     end
#   end
#
# Both helper methods +respond_to+ and +respond_with+ let you define custom
# handlers like the one above for +text/plain+. +respond_with+ additionally
# takes a template name and/or an object to offer the following default
# behavior:
#
# * If a template name is given, search for a template called
#   +name.format.engine+ (+index.xml.nokogiri+ in the above example).
# * If a template name is given, search for a templated called +name.engine+
#   for engines known to result in the requested format (+index.haml+).
# * If a file extension associated with the mime type is known to Sinatra, and
#   the object responds to +to_extension+, call that method and use the result
#   (+data.to_json+).
#
# == Security
#
# Since methods are triggered based on client input, this can lead to security
# issues (but not as severe as those might appear in the first place: keep in
# mind that only known file extensions are used). You should limit
# the possible formats you serve.
#
# This is possible with the +provides+ condition:
#
#   get '/', :provides => [:html, :json, :xml, :atom] do
#     respond_with :index, :name => 'example'
#   end
#
# However, since you have to set +provides+ for every route, this extension
# adds an app global (class method) `respond_to`, that lets you define content
# types for all routes:
#
#   respond_to :html, :json, :xml, :atom
#   get('/a') { respond_with :index, :name => 'a' }
#   get('/b') { respond_with :index, :name => 'b' }
#
# == Custom Types
#
# Use the +on+ method for defining actions for custom types:
#
#   get '/' do
#     respond_to do |f|
#       f.xml { nokogiri :index }
#       f.on('application/custom') { custom_action }
#       f.on('text/*') { data.to_s }
#       f.on('*/*') { "matches everything" }
#     end
#   end
#
# Definition order does not matter.
#
# source://sinatra-contrib//lib/sinatra/respond_with.rb#90
module Sinatra::RespondWith
  # source://sinatra-contrib//lib/sinatra/respond_with.rb#208
  def mime_type(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#201
  def remap_extensions; end

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#227
  def rendering_method(engine); end

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#214
  def respond_to(*formats); end

  private

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#236
  def compile!(verb, path, block, **options); end

  class << self
    # source://sinatra-contrib//lib/sinatra/respond_with.rb#250
    def engines; end

    # source://sinatra-contrib//lib/sinatra/respond_with.rb#241
    def jrubyify(engs); end

    # source://sinatra-contrib//lib/sinatra/respond_with.rb#264
    def registered(base); end
  end
end

# source://sinatra-contrib//lib/sinatra/respond_with.rb#91
class Sinatra::RespondWith::Format
  # @return [Format] a new instance of Format
  #
  # source://sinatra-contrib//lib/sinatra/respond_with.rb#92
  def initialize(app); end

  # @yield [_self]
  # @yieldparam _self [Sinatra::RespondWith::Format] the object that the method was called on
  #
  # source://sinatra-contrib//lib/sinatra/respond_with.rb#109
  def finish; end

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#126
  def method_missing(method, *args, &block); end

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#99
  def on(type, &block); end
end

# source://sinatra-contrib//lib/sinatra/respond_with.rb#133
module Sinatra::RespondWith::Helpers
  include ::Sinatra::JSON

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#170
  def respond_to(&block); end

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#136
  def respond_with(template, object = T.unsafe(nil), &block); end

  private

  # source://sinatra-contrib//lib/sinatra/respond_with.rb#176
  def template_for(name, exts); end
end

# = Sinatra::Streaming
#
# Sinatra 1.3 introduced the +stream+ helper. This addon improves the
# streaming API by making the stream object imitate an IO object, turning
# it into a real Deferrable and making the body play nicer with middleware
# unaware of streaming.
#
# == IO-like behavior
#
# This is useful when passing the stream object to a library expecting an
# IO or StringIO object.
#
#   get '/' do
#     stream do |out|
#       out.puts "Hello World!", "How are you?"
#       out.write "Written #{out.pos} bytes so far!\n"
#       out.putc(65) unless out.closed?
#       out.flush
#     end
#   end
#
# == Better Middleware Handling
#
# Blocks passed to #map! or #map will actually be applied when streaming
# takes place (as you might have suspected, #map! applies modifications
# to the current body, while #map creates a new one):
#
#   class StupidMiddleware
#     def initialize(app) @app = app end
#
#     def call(env)
#       status, headers, body = @app.call(env)
#       body.map! { |e| e.upcase }
#       [status, headers, body]
#     end
#   end
#
#   use StupidMiddleware
#
#   get '/' do
#     stream do |out|
#       out.puts "still"
#       sleep 1
#       out.puts "streaming"
#     end
#   end
#
# Even works if #each is used to generate an Enumerator:
#
#   def call(env)
#     status, headers, body = @app.call(env)
#     body = body.each.map { |s| s.upcase }
#     [status, headers, body]
#   end
#
# Note that both examples violate the Rack specification.
#
# == Setup
#
# In a classic application:
#
#   require "sinatra"
#   require "sinatra/streaming"
#
# In a modular application:
#
#   require "sinatra/base"
#   require "sinatra/streaming"
#
#   class MyApp < Sinatra::Base
#     helpers Sinatra::Streaming
#   end
#
# source://sinatra-contrib//lib/sinatra/streaming.rb#78
module Sinatra::Streaming
  # source://sinatra-contrib//lib/sinatra/streaming.rb#79
  def stream(*_arg0); end
end

# source://sinatra-contrib//lib/sinatra/streaming.rb#87
module Sinatra::Streaming::Stream
  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#100
  def <<(data); end

  # Returns the value of attribute app.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def app=(_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def bytes(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#208
  def chars(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#160
  def close_read; end

  # Returns the value of attribute closed.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def closed; end

  # Sets the attribute closed
  #
  # @param value the value to set the attribute closed to.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def closed=(_arg0); end

  # Returns the value of attribute closed.
  def closed?; end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#164
  def closed_read?; end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#168
  def closed_write?; end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#110
  def each; end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#208
  def each_byte(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#208
  def each_char(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#208
  def each_line(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def eof(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def eof?(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#172
  def external_encoding; end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#220
  def flush(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#220
  def fsync(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def getbyte(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def getc(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def gets(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#220
  def internal_encoding(*_arg0); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#237
  def isatty; end

  # Returns the value of attribute lineno.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def lineno=(_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#208
  def lines(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#117
  def map(&block); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#122
  def map!(&block); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#220
  def pid(*_arg0); end

  # Returns the value of attribute pos.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def pos; end

  # Sets the attribute pos
  #
  # @param value the value to set the attribute pos to.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def pos=(_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#142
  def print(*args); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#147
  def printf(format, *args); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#151
  def putc(c); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#155
  def puts(*args); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def read(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def read_nonblock(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def readbyte(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def readchar(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def readline(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def readlines(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def readpartial(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#182
  def rewind; end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#227
  def seek(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#178
  def settings; end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#233
  def sync; end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def sysread(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#227
  def sysseek(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#134
  def syswrite(data); end

  # Returns the value of attribute pos.
  def tell; end

  # Returns the value of attribute transformer.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def transformer; end

  # Sets the attribute transformer
  #
  # @param value the value to set the attribute transformer to.
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#88
  def transformer=(_arg0); end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#237
  def tty?; end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def ungetbyte(*_arg0); end

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def ungetc(*_arg0); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#134
  def write(data); end

  # source://sinatra-contrib//lib/sinatra/streaming.rb#134
  def write_nonblock(data); end

  private

  # @raise [IOError]
  #
  # source://sinatra-contrib//lib/sinatra/streaming.rb#186
  def not_open_for_reading(*_arg0); end

  class << self
    # @private
    #
    # source://sinatra-contrib//lib/sinatra/streaming.rb#92
    def extended(obj); end
  end
end

# Helper methods to ease testing your Sinatra application. Partly extracted
# from Sinatra. Testing framework agnostic.
#
# source://sinatra-contrib//lib/sinatra/test_helpers.rb#17
module Sinatra::TestHelpers
  include ::Rack::Test::Methods
  extend ::Forwardable

  # Returns a Rack::Lint-wrapped Sinatra app.
  #
  # If no app has been configured, a new subclass of Sinatra::Base will be
  # used and stored.
  #
  # (Rack::Lint validates your application and the requests and
  # responses according to the Rack spec.)
  #
  # @return [Sinatra::Base]
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#151
  def app; end

  # Replaces the configured app.
  #
  # @param base [Sinatra::Base] a configured app
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#136
  def app=(base); end

  # Body of last_response
  #
  # @return [String] body of the last response
  # @see https://www.rubydoc.info/github/rack/rack/main/Rack/Response#body-instance_method
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def body(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def configure(*args, **_arg1, &block); end

  # Returns a {https://www.rubydoc.info/github/rack/rack-test/Rack/Test/CookieJar Rack::Test::CookieJar}.
  #
  # @return [Rack::Test::CookieJar]
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def cookie_jar(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def disable(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def enable(*args, **_arg1, &block); end

  # Return the Rack environment used for a request to `uri`.
  #
  # @return [Hash]
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def env_for(*args, **_arg1, &block); end

  # Errors of last_response
  #
  # @return [Array] errors of the last response
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def errors(*args, **_arg1, &block); end

  # Headers of last_response
  #
  # @return [Hash] hash of the last response
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def headers(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def helpers(*args, **_arg1, &block); end

  # @return The env of the last request
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#198
  def last_env; end

  # @return [Boolean]
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#181
  def last_request?; end

  # Instantiate and configure a mock Sinatra app.
  #
  # Takes a `base` app class, or defaults to Sinatra::Base, and instantiates
  # an app instance. Any given code in `block` is `class_eval`'d on this new
  # instance before the instance is returned.
  #
  # @param base [Sinatra::Base] App base class
  # @return [Sinatra] Configured mocked app
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#123
  def mock_app(base = T.unsafe(nil), &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def register(*args, **_arg1, &block); end

  # @raise [Rack::Test:Error] If sessions are not enabled for app
  # @return [Hash] Session of last request, or the empty Hash
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#190
  def session; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def set(*args, **_arg1, &block); end

  # Replaces the configured app.
  #
  # @param base [Sinatra::Base] a configured app
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#136
  def set_app(base); end

  # Returns the value of attribute settings.
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#20
  def settings; end

  # Sets the attribute settings
  #
  # @param value the value to set the attribute settings to.
  #
  # source://sinatra-contrib//lib/sinatra/test_helpers.rb#20
  def settings=(_arg0); end

  # HTTP status of last_response
  #
  # @return [Integer] HTTP status of the last response
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def status(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def use(*args, **_arg1, &block); end
end
