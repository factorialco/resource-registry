# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `resource_registry` gem.
# Please instead update this file by running `bin/tapioca gem resource_registry`.


# typed: true

# Represents an instance of an object that may or may not be present. This can be useful in certain
# cases where `nil` represents a valid value instead of an absent value, i.e. update DTOs.
#
# An useful way to think about `Maybe` is as a collection, like `Array` or `Set` but that can only
# hold a maximum of 1 elements at a time.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://resource_registry//lib/schema_registry/maybe/absent.rb#4
module Maybe
  extend T::Generic
  include ::Kernel
  extend ::RuntimeGeneric

  interface!

  Value = type_member(:out) { { upper: BasicObject } }

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#111
  sig { abstract.returns(T::Boolean) }
  def absent?; end

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#118
  sig { abstract.returns(T::Boolean) }
  def empty?; end

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#168
  sig { abstract.params(_block: T.proc.params(value: Value).returns(T::Boolean)).returns(Maybe[Value]) }
  def filter(&_block); end

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#188
  sig do
    abstract
      .type_parameters(:Default)
      .params(
        _block: T.proc.params(value: Value).returns(T.all(::BasicObject, T.type_parameter(:Default)))
      ).returns(Maybe[T.all(::BasicObject, T.type_parameter(:Default))])
  end
  def map(&_block); end

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#128
  sig do
    abstract
      .type_parameters(:Default)
      .params(
        default: T.type_parameter(:Default)
      ).returns(T.any(T.type_parameter(:Default), Value))
  end
  def or_default(default); end

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#106
  sig { abstract.returns(T::Boolean) }
  def present?; end

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#153
  sig do
    abstract
      .type_parameters(:Return)
      .params(
        _block: T.proc.returns(T.type_parameter(:Return))
      ).returns(T.nilable(T.type_parameter(:Return)))
  end
  def when_absent(&_block); end

  # @abstract
  #
  # source://resource_registry//lib/schema_registry/maybe.rb#142
  sig do
    abstract
      .type_parameters(:Return)
      .params(
        _block: T.proc.params(v: Value).returns(T.type_parameter(:Return))
      ).returns(T.nilable(T.type_parameter(:Return)))
  end
  def when_present(&_block); end

  class << self
    # source://resource_registry//lib/schema_registry/maybe.rb#79
    sig { returns(Maybe::Absent) }
    def absent; end

    # source://resource_registry//lib/schema_registry/maybe.rb#65
    sig { returns(Maybe::Absent) }
    def empty; end

    # source://resource_registry//lib/schema_registry/maybe.rb#100
    sig do
      type_parameters(:Value)
        .params(
          value: T.all(::BasicObject, T.type_parameter(:Value))
        ).returns(Maybe[T.all(::BasicObject, T.type_parameter(:Value))])
    end
    def from(value); end

    sig do
      type_parameters(:Value)
        .params(
          value: T.all(BasicObject, T.type_parameter(:Value))
        ).returns(Maybe[T.all(BasicObject, T.type_parameter(:Value))])
    end
    def new(
      value # Creates an instance containing the specified value.
            # Necessary to make this work with sorbet-coerce
); end

    # source://resource_registry//lib/schema_registry/maybe.rb#72
    sig { returns(Maybe::Absent) }
    def none; end

    # source://resource_registry//lib/schema_registry/maybe.rb#42
    sig do
      type_parameters(:Key)
        .params(
          input: T::Hash[T.type_parameter(:Key), T.untyped]
        ).returns(T::Hash[T.type_parameter(:Key), T.untyped])
    end
    def strip(input); end
  end
end

# Class used to represent the empty case
#
# source://resource_registry//lib/schema_registry/maybe/absent.rb#6
class Maybe::Absent
  extend T::Generic
  include ::Maybe

  Value = type_member { { fixed: T.noreturn } }

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#84
  sig(:final) { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#20
  sig(:final) { override.returns(::TrueClass) }
  def absent?; end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#25
  sig(:final) { override.returns(::TrueClass) }
  def empty?; end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#66
  sig(:final) { override.params(_block: T.proc.params(value: Value).returns(T::Boolean)).returns(Maybe[Value]) }
  def filter(&_block); end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#79
  sig(:final) do
    override
      .type_parameters(:Default)
      .params(
        _block: T.proc.params(value: Value).returns(T.type_parameter(:Default))
      ).returns(Maybe[T.all(::BasicObject, T.type_parameter(:Default))])
  end
  def map(&_block); end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#35
  sig(:final) do
    override
      .type_parameters(:Default)
      .params(
        default: T.type_parameter(:Default)
      ).returns(T.type_parameter(:Default))
  end
  def or_default(default); end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#15
  sig(:final) { override.returns(::FalseClass) }
  def present?; end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#57
  sig(:final) do
    override
      .type_parameters(:Return)
      .params(
        _block: T.proc.returns(T.type_parameter(:Return))
      ).returns(T.nilable(T.type_parameter(:Return)))
  end
  def when_absent(&_block); end

  # source://resource_registry//lib/schema_registry/maybe/absent.rb#47
  sig(:final) do
    override
      .type_parameters(:Return)
      .params(
        _block: T.proc.params(v: Value).returns(T.type_parameter(:Return))
      ).returns(T.nilable(T.type_parameter(:Return)))
  end
  def when_present(&_block); end
end

# Class used to represent the case when a value is available
#
# source://resource_registry//lib/schema_registry/maybe/present.rb#6
class Maybe::Present
  extend T::Generic
  include ::Maybe

  Value = type_member(:out) { { upper: BasicObject } }

  # source://resource_registry//lib/schema_registry/maybe/present.rb#15
  sig(:final) { params(value: Value).void }
  def initialize(value); end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#95
  sig(:final) { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#25
  sig(:final) { override.returns(::FalseClass) }
  def absent?; end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#30
  sig(:final) { override.returns(::FalseClass) }
  def empty?; end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#71
  sig(:final) { override.params(_block: T.proc.params(value: Value).returns(T::Boolean)).returns(Maybe[Value]) }
  def filter(&_block); end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#89
  sig(:final) do
    override
      .type_parameters(:Default)
      .params(
        _block: T.proc.params(value: Value).returns(T.all(::BasicObject, T.type_parameter(:Default)))
      ).returns(Maybe[T.all(::BasicObject, T.type_parameter(:Default))])
  end
  def map(&_block); end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#40
  sig(:final) { override.type_parameters(:Default).params(_default: T.type_parameter(:Default)).returns(Value) }
  def or_default(_default); end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#20
  sig(:final) { override.returns(::TrueClass) }
  def present?; end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#102
  sig(:final) { returns(Value) }
  def value; end

  # source://resource_registry//lib/schema_registry/maybe/present.rb#62
  sig(:final) do
    override
      .type_parameters(:Return)
      .params(
        _block: T.proc.returns(T.type_parameter(:Return))
      ).returns(T.nilable(T.type_parameter(:Return)))
  end
  def when_absent(&_block); end

  # @yield [value]
  #
  # source://resource_registry//lib/schema_registry/maybe/present.rb#52
  sig(:final) do
    override
      .type_parameters(:Return)
      .params(
        _block: T.proc.params(v: Value).returns(T.type_parameter(:Return))
      ).returns(T.nilable(T.type_parameter(:Return)))
  end
  def when_present(&_block); end
end

# Entry point for ResourceRegistry
#
# source://resource_registry//lib/public/relationship_type.rb#3
module ResourceRegistry
  class << self
    # source://resource_registry//lib/resource_registry.rb#27
    sig { returns(::ResourceRegistry::Configuration) }
    def configuration; end

    # @yield [configuration]
    #
    # source://resource_registry//lib/resource_registry.rb#32
    sig { void }
    def configure; end
  end
end

# source://resource_registry//lib/public/capabilities/capability_config.rb#5
module ResourceRegistry::Capabilities; end

# Represents configuration for a specific resource capability
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://resource_registry//lib/public/capabilities/capability_config.rb#7
module ResourceRegistry::Capabilities::CapabilityConfig
  include ::Kernel

  requires_ancestor { Object }

  interface!

  mixes_in_class_methods ::ResourceRegistry::Capabilities::CapabilityConfig::ClassMethods

  # @abstract
  #
  # source://resource_registry//lib/public/capabilities/capability_config.rb#31
  sig { abstract.returns(T::Hash[::String, T.untyped]) }
  def serialize; end
end

# Class methods interface for capability configuration
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://resource_registry//lib/public/capabilities/capability_config.rb#15
module ResourceRegistry::Capabilities::CapabilityConfig::ClassMethods
  abstract!

  # The key of the capability, this key will be used to take it from yaml configuration
  #
  # @abstract
  #
  # source://resource_registry//lib/public/capabilities/capability_config.rb#22
  sig { abstract.returns(::Symbol) }
  def key; end
end

# This class enumerates features that are available to a resource. Each
# resource knows which subset of these it needs to be used with.
#
# source://resource_registry//lib/public/capability_factory.rb#6
class ResourceRegistry::CapabilityFactory
  class << self
    # source://resource_registry//lib/public/capability_factory.rb#37
    sig do
      params(
        capability: ::ResourceRegistry::Capabilities::CapabilityConfig
      ).returns(T::Hash[::String, T.untyped])
    end
    def dump(capability); end

    # source://resource_registry//lib/public/capability_factory.rb#22
    sig do
      params(
        data: T::Hash[::String, T.untyped],
        capabilities: T::Hash[::Symbol, T.all(T.class_of(T::Struct), T::Class[::ResourceRegistry::Capabilities::CapabilityConfig])]
      ).returns(::ResourceRegistry::Capabilities::CapabilityConfig)
    end
    def load(data, capabilities: T.unsafe(nil)); end
  end
end

# source://resource_registry//lib/public/configuration.rb#10
class ResourceRegistry::Configuration
  # source://resource_registry//lib/public/configuration.rb#21
  sig { void }
  def initialize; end

  # source://resource_registry//lib/public/configuration.rb#52
  sig do
    returns(T::Hash[::Symbol, T.all(T.class_of(T::Struct), T::Class[::ResourceRegistry::Capabilities::CapabilityConfig])])
  end
  def capabilities; end

  # source://resource_registry//lib/public/configuration.rb#37
  sig { params(capability: ::Symbol, klass: T.class_of(ResourceRegistry::Capabilities::CapabilityConfig)).void }
  def register_capability(capability, klass); end

  # source://resource_registry//lib/public/configuration.rb#27
  sig { params(type: ::String, klass: T.class_of(ResourceRegistry::RelationshipType)).void }
  def register_relationship_type(type, klass); end

  # source://resource_registry//lib/public/configuration.rb#42
  sig { returns(T::Hash[::String, T::Class[::ResourceRegistry::RelationshipType]]) }
  def relationship_types; end
end

# source://resource_registry//lib/public/configuration.rb#13
ResourceRegistry::Configuration::DEFAULT_RELATIONSHIP_TYPES = T.let(T.unsafe(nil), Hash)

# source://resource_registry//lib/public/entity_finder.rb#4
class ResourceRegistry::EntityFinder
  class << self
    # source://resource_registry//lib/public/entity_finder.rb#12
    sig do
      params(
        repository: T.class_of(ResourceRegistry::Repositories::Base)
      ).returns(T.nilable(T.class_of(T::Struct)))
    end
    def call(repository:); end
  end
end

# source://resource_registry//lib/public/registry.rb#8
class ResourceRegistry::Registry
  # source://resource_registry//lib/public/registry.rb#18
  sig { params(resources: T::Array[::ResourceRegistry::Resource]).void }
  def initialize(resources:); end

  # source://resource_registry//lib/public/registry.rb#32
  sig { params(identifier: ::String).returns(T.nilable(::ResourceRegistry::Resource)) }
  def fetch(identifier); end

  # @raise [UnableToFindResourceError]
  #
  # source://resource_registry//lib/public/registry.rb#37
  sig { params(identifier: ::String).returns(::ResourceRegistry::Resource) }
  def fetch!(identifier); end

  # source://resource_registry//lib/public/registry.rb#56
  sig { returns(T::Hash[::String, ::ResourceRegistry::Resource]) }
  def fetch_all; end

  # source://resource_registry//lib/public/registry.rb#51
  sig do
    params(
      repository_class: T::Class[ResourceRegistry::Repositories::Base[T.untyped]]
    ).returns(T.nilable(::ResourceRegistry::Resource))
  end
  def fetch_for_repository(repository_class); end

  # source://resource_registry//lib/public/registry.rb#65
  sig do
    params(
      capabilities: T::Class[::ResourceRegistry::Capabilities::CapabilityConfig]
    ).returns(T::Array[::ResourceRegistry::Resource])
  end
  def fetch_with_capabilities(*capabilities); end

  # source://resource_registry//lib/public/registry.rb#79
  sig do
    params(
      repository: T::Class[ResourceRegistry::Repositories::Base[T.untyped]]
    ).returns(T.nilable(::ResourceRegistry::Resource))
  end
  def find_by_repository(repository); end

  private

  # source://resource_registry//lib/public/registry.rb#89
  sig { params(resources: T::Array[::ResourceRegistry::Resource]).returns(T::Boolean) }
  def duplicated_identifier?(resources); end

  # source://resource_registry//lib/public/registry.rb#86
  sig { returns(T::Hash[::String, ::ResourceRegistry::Resource]) }
  def resources; end

  # @return [Hash{String => Resource}]
  #
  # source://resource_registry//lib/public/registry.rb#86
  def resources=(_arg0); end
end

# source://resource_registry//lib/public/registry.rb#14
class ResourceRegistry::Registry::DuplicatedIdentifierError < ::StandardError; end

# source://resource_registry//lib/public/registry.rb#11
class ResourceRegistry::Registry::UnableToFindResourceError < ::StandardError; end

# source://resource_registry//lib/public/relationship.rb#8
class ResourceRegistry::Relationship < ::T::Struct
  const :name, ::String
  const :resource_id, ::Symbol
  const :field, ::Symbol
  const :primary_key, ::Symbol, default: T.unsafe(nil)
  const :type, ::ResourceRegistry::RelationshipType
  const :fixed_dto_params, T.nilable(T::Hash[::String, T.untyped])
  const :optional, T::Boolean

  # source://resource_registry//lib/public/relationship.rb#26
  sig { returns(T::Hash[::String, T.untyped]) }
  def dump; end

  # Are there multiple resources in the other side of the relationship?
  #
  # source://resource_registry//lib/public/relationship.rb#21
  sig { returns(T::Boolean) }
  def many_cardinality?; end

  # source://resource_registry//lib/public/relationship.rb#71
  sig { returns(T::Boolean) }
  def optional?; end

  # The field used to define the left side of a relationship. This is the
  # field that it will be passed to the next resolver to fetch the data.
  #
  # source://resource_registry//lib/public/relationship.rb#66
  sig { returns(T.nilable(::Symbol)) }
  def reference_id; end

  # We provide this in the dataloader, we encourage not to perform joins in
  # frontend, so we skip ids to be exposed.
  # FIXME: Review if this belongs to this layer or is coupled to GraphQL
  #
  # source://resource_registry//lib/public/relationship.rb#57
  sig { params(argument: ::String).returns(T::Boolean) }
  def should_skip_argument?(argument); end

  class << self
    # source://sorbet-runtime/0.5.11670/lib/types/struct.rb#13
    def inherited(s); end

    # source://resource_registry//lib/public/relationship.rb#39
    sig { params(spec: T::Hash[::String, T.untyped]).returns(::ResourceRegistry::Relationship) }
    def load(spec); end
  end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://resource_registry//lib/public/relationship_type.rb#4
module ResourceRegistry::RelationshipType
  requires_ancestor { Object }

  abstract!

  # source://resource_registry//lib/public/relationship_type.rb#26
  sig { params(spec: T::Hash[::String, T.untyped]).void }
  def initialize(spec); end

  # @abstract
  #
  # source://resource_registry//lib/public/relationship_type.rb#64
  sig { abstract.returns(::Integer) }
  def complexity; end

  # source://resource_registry//lib/public/relationship_type.rb#107
  sig { returns(::Symbol) }
  def field; end

  # source://resource_registry//lib/public/relationship_type.rb#68
  sig { returns(T::Boolean) }
  def forward_entities?; end

  # source://resource_registry//lib/public/relationship_type.rb#74
  sig { returns(T::Boolean) }
  def forward_selected_fields?; end

  # @abstract
  #
  # source://resource_registry//lib/public/relationship_type.rb#43
  sig { abstract.returns(T::Boolean) }
  def many_cardinality?; end

  # source://resource_registry//lib/public/relationship_type.rb#97
  sig { returns(::String) }
  def name; end

  # source://resource_registry//lib/public/relationship_type.rb#92
  sig { returns(T::Array[T::Hash[::String, T.untyped]]) }
  def nested_fields; end

  # @abstract
  #
  # source://resource_registry//lib/public/relationship_type.rb#88
  sig do
    abstract
      .params(
        dto: T::Hash[::Symbol, T.untyped],
        ids: T::Array[T.any(::Integer, ::String)],
        rel: ::ResourceRegistry::Relationship,
        parent_resource: T.nilable(::ResourceRegistry::Resource)
      ).returns(T::Hash[::Symbol, T.untyped])
  end
  def prepare_dto(dto, ids, rel, parent_resource); end

  # source://resource_registry//lib/public/relationship_type.rb#112
  sig { returns(::Symbol) }
  def primary_key; end

  # The field defined to resolve the other side of the relationship, it can be field or primary_key
  #
  # @abstract
  #
  # source://resource_registry//lib/public/relationship_type.rb#48
  sig { abstract.params(relationship: ::ResourceRegistry::Relationship).returns(::Symbol) }
  def reference_id(relationship); end

  # source://resource_registry//lib/public/relationship_type.rb#128
  sig { overridable.returns(T.nilable(::Symbol)) }
  def relationship_field_name; end

  # source://resource_registry//lib/public/relationship_type.rb#102
  sig { returns(::Symbol) }
  def resource_id; end

  # @abstract
  #
  # source://resource_registry//lib/public/relationship_type.rb#31
  sig { abstract.returns(::String) }
  def serialize; end

  # @abstract
  #
  # source://resource_registry//lib/public/relationship_type.rb#60
  sig do
    abstract
      .params(
        loaded_data: T::Array[T::Hash[::String, T.untyped]],
        ids: T.untyped,
        relationship: ::ResourceRegistry::Relationship
      ).returns(T::Array[T.nilable(T.any(T::Array[T::Hash[::String, T.untyped]], T::Hash[::String, T.untyped]))])
  end
  def shape_result(loaded_data, ids, relationship); end

  # @abstract
  #
  # source://resource_registry//lib/public/relationship_type.rb#39
  sig { abstract.params(argument: ::String, relationship: ::ResourceRegistry::Relationship).returns(T::Boolean) }
  def should_skip_argument?(argument, relationship); end

  # source://resource_registry//lib/public/relationship_type.rb#121
  sig { overridable.params(read_dto: T.nilable(T.class_of(T::Struct))).returns(T::Boolean) }
  def valid_relationship_field?(read_dto); end
end

# source://resource_registry//lib/public/relationship_type.rb#13
ResourceRegistry::RelationshipType::ResultShape = T.type_alias { T::Array[T.nilable(T.any(T::Array[T::Hash[::String, T.untyped]], T::Hash[::String, T.untyped]))] }

# source://resource_registry//lib/public/relationship_type_factory.rb#4
module ResourceRegistry::RelationshipTypeFactory
  class << self
    # FIXME: Allow a more dynamic and future proof way to register relationship types
    #
    # source://resource_registry//lib/public/relationship_type_factory.rb#9
    sig { params(spec: T.untyped).returns(::ResourceRegistry::RelationshipType) }
    def from_spec(spec); end
  end
end

# source://resource_registry//lib/public/relationship_types/has_many.rb#7
module ResourceRegistry::RelationshipTypes; end

# source://resource_registry//lib/public/relationship_types/belongs_to.rb#8
class ResourceRegistry::RelationshipTypes::BelongsTo
  include ::ResourceRegistry::RelationshipType

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#64
  sig { override.returns(::Integer) }
  def complexity; end

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#28
  sig { override.returns(T::Boolean) }
  def many_cardinality?; end

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#78
  sig do
    override
      .params(
        dto: T::Hash[::Symbol, T.untyped],
        ids: T::Array[T.any(::Integer, ::String)],
        rel: ::ResourceRegistry::Relationship,
        _parent_resource: T.nilable(::ResourceRegistry::Resource)
      ).returns(T::Hash[::Symbol, T.untyped])
  end
  def prepare_dto(dto, ids, rel, _parent_resource); end

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#33
  sig { override.params(relationship: ::ResourceRegistry::Relationship).returns(::Symbol) }
  def reference_id(relationship); end

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#84
  sig { override.returns(::Symbol) }
  def relationship_field_name; end

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#14
  sig { override.returns(::String) }
  def serialize; end

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#55
  sig do
    override
      .params(
        loaded_data: T::Array[T::Hash[::String, T.untyped]],
        ids: T.untyped,
        relationship: ::ResourceRegistry::Relationship
      ).returns(T::Array[T.nilable(T.any(T::Array[T::Hash[::String, T.untyped]], T::Hash[::String, T.untyped]))])
  end
  def shape_result(loaded_data, ids, relationship); end

  # source://resource_registry//lib/public/relationship_types/belongs_to.rb#23
  sig { override.params(argument: ::String, relationship: ::ResourceRegistry::Relationship).returns(T::Boolean) }
  def should_skip_argument?(argument, relationship); end
end

# source://resource_registry//lib/public/relationship_types/has_many.rb#8
class ResourceRegistry::RelationshipTypes::HasMany
  include ::ResourceRegistry::RelationshipType

  # source://resource_registry//lib/public/relationship_types/has_many.rb#61
  sig { override.returns(::Integer) }
  def complexity; end

  # source://resource_registry//lib/public/relationship_types/has_many.rb#28
  sig { override.returns(T::Boolean) }
  def many_cardinality?; end

  # source://resource_registry//lib/public/relationship_types/has_many.rb#75
  sig do
    override
      .params(
        dto: T::Hash[::Symbol, T.untyped],
        ids: T::Array[T.any(::Integer, ::String)],
        rel: ::ResourceRegistry::Relationship,
        _parent_resource: T.nilable(::ResourceRegistry::Resource)
      ).returns(T::Hash[::Symbol, T.untyped])
  end
  def prepare_dto(dto, ids, rel, _parent_resource); end

  # source://resource_registry//lib/public/relationship_types/has_many.rb#33
  sig { override.params(relationship: ::ResourceRegistry::Relationship).returns(::Symbol) }
  def reference_id(relationship); end

  # source://resource_registry//lib/public/relationship_types/has_many.rb#81
  sig { override.returns(::Symbol) }
  def relationship_field_name; end

  # source://resource_registry//lib/public/relationship_types/has_many.rb#14
  sig { override.returns(::String) }
  def serialize; end

  # source://resource_registry//lib/public/relationship_types/has_many.rb#55
  sig do
    override
      .params(
        loaded_data: T::Array[T::Hash[::String, T.untyped]],
        ids: T.untyped,
        relationship: ::ResourceRegistry::Relationship
      ).returns(T::Array[T.nilable(T.any(T::Array[T::Hash[::String, T.untyped]], T::Hash[::String, T.untyped]))])
  end
  def shape_result(loaded_data, ids, relationship); end

  # source://resource_registry//lib/public/relationship_types/has_many.rb#23
  sig { override.params(argument: ::String, relationship: ::ResourceRegistry::Relationship).returns(T::Boolean) }
  def should_skip_argument?(argument, relationship); end
end

# source://resource_registry//lib/public/relationship_types/has_many_through.rb#8
class ResourceRegistry::RelationshipTypes::HasManyThrough
  include ::ResourceRegistry::RelationshipType

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#62
  sig { override.returns(::Integer) }
  def complexity; end

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#28
  sig { override.returns(T::Boolean) }
  def many_cardinality?; end

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#76
  sig do
    override
      .params(
        dto: T::Hash[::Symbol, T.untyped],
        ids: T::Array[T.any(::Integer, ::String)],
        _rel: ::ResourceRegistry::Relationship,
        _parent_resource: T.nilable(::ResourceRegistry::Resource)
      ).returns(T::Hash[::Symbol, T.untyped])
  end
  def prepare_dto(dto, ids, _rel, _parent_resource); end

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#33
  sig { override.params(relationship: ::ResourceRegistry::Relationship).returns(::Symbol) }
  def reference_id(relationship); end

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#82
  sig { override.returns(::Symbol) }
  def relationship_field_name; end

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#14
  sig { override.returns(::String) }
  def serialize; end

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#55
  sig do
    override
      .params(
        loaded_data: T::Array[T::Hash[::String, T.untyped]],
        ids: T.untyped,
        _relationship: ::ResourceRegistry::Relationship
      ).returns(T::Array[T.nilable(T.any(T::Array[T::Hash[::String, T.untyped]], T::Hash[::String, T.untyped]))])
  end
  def shape_result(loaded_data, ids, _relationship); end

  # source://resource_registry//lib/public/relationship_types/has_many_through.rb#23
  sig { override.params(argument: ::String, relationship: ::ResourceRegistry::Relationship).returns(T::Boolean) }
  def should_skip_argument?(argument, relationship); end
end

# source://resource_registry//lib/public/relationship_types/has_one.rb#8
class ResourceRegistry::RelationshipTypes::HasOne
  include ::ResourceRegistry::RelationshipType

  # source://resource_registry//lib/public/relationship_types/has_one.rb#63
  sig { override.returns(::Integer) }
  def complexity; end

  # source://resource_registry//lib/public/relationship_types/has_one.rb#28
  sig { override.returns(T::Boolean) }
  def many_cardinality?; end

  # source://resource_registry//lib/public/relationship_types/has_one.rb#77
  sig do
    override
      .params(
        dto: T::Hash[::Symbol, T.untyped],
        ids: T::Array[T.any(::Integer, ::String)],
        rel: ::ResourceRegistry::Relationship,
        _parent_resource: T.nilable(::ResourceRegistry::Resource)
      ).returns(T::Hash[::Symbol, T.untyped])
  end
  def prepare_dto(dto, ids, rel, _parent_resource); end

  # FIXME: Review if this is actually reference_id
  #
  # source://resource_registry//lib/public/relationship_types/has_one.rb#34
  sig { override.params(relationship: ::ResourceRegistry::Relationship).returns(::Symbol) }
  def reference_id(relationship); end

  # source://resource_registry//lib/public/relationship_types/has_one.rb#83
  sig { override.returns(::Symbol) }
  def relationship_field_name; end

  # source://resource_registry//lib/public/relationship_types/has_one.rb#14
  sig { override.returns(::String) }
  def serialize; end

  # source://resource_registry//lib/public/relationship_types/has_one.rb#56
  sig do
    override
      .params(
        loaded_data: T::Array[T::Hash[::String, T.untyped]],
        ids: T.untyped,
        relationship: ::ResourceRegistry::Relationship
      ).returns(T::Array[T.nilable(T.any(T::Array[T::Hash[::String, T.untyped]], T::Hash[::String, T.untyped]))])
  end
  def shape_result(loaded_data, ids, relationship); end

  # source://resource_registry//lib/public/relationship_types/has_one.rb#23
  sig { override.params(argument: ::String, relationship: ::ResourceRegistry::Relationship).returns(T::Boolean) }
  def should_skip_argument?(argument, relationship); end
end

# source://resource_registry//lib/public/repositories/base.rb#8
module ResourceRegistry::Repositories; end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://resource_registry//lib/public/repositories/base.rb#9
module ResourceRegistry::Repositories::Base
  extend T::Generic
  include ::Kernel
  extend ::RuntimeGeneric

  abstract!

  Entity = type_member { { upper: T::Struct } }

  # source://resource_registry//lib/public/repositories/base.rb#33
  sig { overridable.params(dto: T.untyped, context: T.untyped).returns(T.untyped) }
  def read(dto:, context:); end

  # source://resource_registry//lib/public/repositories/base.rb#42
  sig { overridable.params(entity: Entity, tags: T::Set[T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def serialize(entity:, tags: T.unsafe(nil)); end

  private

  # @raise [NotImplementedError]
  #
  # source://resource_registry//lib/public/repositories/base.rb#73
  sig { params(method: T.nilable(::Symbol)).returns(T.noreturn) }
  def raise_error(method); end

  # source://resource_registry//lib/public/repositories/base.rb#62
  sig { returns(::ResourceRegistry::Serializer) }
  def serializer; end

  class << self
    # source://resource_registry//lib/public/repositories/base.rb#24
    sig { returns(T.untyped) }
    def entity; end

    # source://resource_registry//lib/public/repositories/base.rb#47
    sig(:final) { returns(::String) }
    def namespace; end

    # source://resource_registry//lib/public/repositories/base.rb#55
    sig(:final) { returns(::String) }
    def resource_name; end
  end
end

# The main class that represents a resource in the system.
#
# source://resource_registry//lib/public/resource.rb#12
class ResourceRegistry::Resource < ::T::Struct
  const :repository_raw, ::String
  const :description, ::String, default: T.unsafe(nil)
  const :capabilities, T::Hash[::Symbol, ::ResourceRegistry::Capabilities::CapabilityConfig], default: T.unsafe(nil)
  const :relationships, T::Hash[::Symbol, ::ResourceRegistry::Relationship], default: T.unsafe(nil)
  const :schema, ::SchemaRegistry::Schema
  const :verbs, T::Hash[::Symbol, ::ResourceRegistry::Verb]
  const :paginateable, T::Boolean, default: T.unsafe(nil)

  # source://resource_registry//lib/public/resource.rb#111
  sig { params(verb: ::Symbol, parameters: T.untyped).returns(::T::Struct) }
  def build_dto(verb, **parameters); end

  # source://resource_registry//lib/public/resource.rb#100
  sig { returns(::String) }
  def camelize; end

  # At first glance this method signature appears funkier than a James Brown record.
  #
  # We declare a generic `CapabilityConfig` type parameter, which we then combine
  # in a type union with the public methods declared by the `Capabilities::CapabilityConfig`
  # interface. As such, the `capability` parameter is typed to be any class that includes
  # the `Capabilities::CapabilityConfig` interface.
  # Then, we declare the return type to be a nullable instance of the `CapabilityConfig`
  # type parameter. The result is Sorbet knows that the return type of the method is
  # always the same as the type of the `capability` parameter that the method is called
  # with, so we never need to cast the result. For example, can can do
  #
  # capability = resource.capability(Comments::Capabilities::Commentable)
  #
  # and Sorbet will know that `capability` is an instance of `Comments::Capabilities::Commentable`
  #
  # source://resource_registry//lib/public/resource.rb#149
  sig do
    type_parameters(:CapabilityConfig)
      .params(
        capability: T.all(::ResourceRegistry::Capabilities::CapabilityConfig::ClassMethods, T::Class[::ResourceRegistry::Capabilities::CapabilityConfig], T::Class[T.type_parameter(:CapabilityConfig)])
      ).returns(T.nilable(T.type_parameter(:CapabilityConfig)))
  end
  def capability(capability); end

  # source://resource_registry//lib/public/resource.rb#187
  sig do
    type_parameters(:CapabilityConfig)
      .params(
        feature: T.all(::ResourceRegistry::Capabilities::CapabilityConfig::ClassMethods, T::Class[::ResourceRegistry::Capabilities::CapabilityConfig], T::Class[T.type_parameter(:CapabilityConfig)])
      ).returns(T.type_parameter(:CapabilityConfig))
  end
  def capability!(feature); end

  # source://resource_registry//lib/public/resource.rb#169
  sig do
    params(
      feature: T.all(::ResourceRegistry::Capabilities::CapabilityConfig::ClassMethods, T::Class[::ResourceRegistry::Capabilities::CapabilityConfig])
    ).returns(T::Boolean)
  end
  def capability?(feature); end

  # source://resource_registry//lib/public/resource.rb#156
  sig { params(key: ::Symbol).returns(T.nilable(::ResourceRegistry::Capabilities::CapabilityConfig)) }
  def capability_by_key(key); end

  # source://resource_registry//lib/public/resource.rb#60
  sig { returns(::String) }
  def collection_name; end

  # source://resource_registry//lib/public/resource.rb#210
  sig { returns(T::Hash[::String, T.untyped]) }
  def dump; end

  # source://resource_registry//lib/public/resource.rb#105
  sig { returns(::String) }
  def humanize; end

  # source://resource_registry//lib/public/resource.rb#51
  sig { returns(::Symbol) }
  def identifier; end

  # source://resource_registry//lib/public/resource.rb#200
  sig { returns(T::Array[::ResourceRegistry::Verb]) }
  def mutation_verbs; end

  # source://resource_registry//lib/public/resource.rb#65
  sig { returns(::Symbol) }
  def name; end

  # source://resource_registry//lib/public/resource.rb#87
  sig(:final) { returns(::String) }
  def namespace; end

  # source://resource_registry//lib/public/resource.rb#40
  sig { returns(::String) }
  def path; end

  # source://resource_registry//lib/public/resource.rb#76
  sig { returns(T::Class[ResourceRegistry::Repositories::Base[T.untyped]]) }
  def repository; end

  # source://resource_registry//lib/public/resource.rb#71
  sig { returns(::String) }
  def resource_name; end

  # source://resource_registry//lib/public/resource.rb#195
  sig { returns(T::Array[::ResourceRegistry::Verb]) }
  def rpc_verbs; end

  # source://resource_registry//lib/public/resource.rb#46
  sig { returns(::String) }
  def slug; end

  # source://resource_registry//lib/public/resource.rb#95
  sig { returns(::String) }
  def underscore; end

  # source://resource_registry//lib/public/resource.rb#205
  sig { params(except: T::Array[::Symbol]).returns(T::Array[::ResourceRegistry::Verb]) }
  def verbs_except(except); end

  class << self
    # source://sorbet-runtime/0.5.11670/lib/types/struct.rb#13
    def inherited(s); end

    # source://resource_registry//lib/public/resource.rb#234
    sig do
      params(
        spec: T::Hash[::String, T.untyped],
        configuration: ::ResourceRegistry::Configuration
      ).returns(::ResourceRegistry::Resource)
    end
    def load(spec, configuration: T.unsafe(nil)); end
  end
end

# source://resource_registry//lib/public/resource.rb#18
class ResourceRegistry::Resource::SchemaNotFound < ::StandardError; end

# source://resource_registry//lib/public/resource.rb#15
class ResourceRegistry::Resource::VerbNotFound < ::StandardError; end

# Constructs a resource struct (like Dtos and Entities) from a hash of arguments
# It's different from the usual T::Struct::new in that it can handle
# the particular cases of our resource objects, such as:
# - nested Dtos
# - arrays of Dtos
# - `Maybe[T]` values
#
# source://resource_registry//lib/public/resource_struct_builder.rb#13
class ResourceRegistry::ResourceStructBuilder
  # source://resource_registry//lib/public/resource_struct_builder.rb#20
  sig { params(resource_type: T.untyped).void }
  def initialize(resource_type); end

  # source://resource_registry//lib/public/resource_struct_builder.rb#25
  sig { params(value: T.untyped).returns(T.untyped) }
  def build(value); end

  private

  # source://resource_registry//lib/public/resource_struct_builder.rb#64
  sig { returns(T::Boolean) }
  def array?; end

  # source://resource_registry//lib/public/resource_struct_builder.rb#145
  sig { params(args: T.nilable(T.all(::Object, T::Enumerable[T.untyped]))).returns(T.untyped) }
  def build_enumerable(args); end

  # source://resource_registry//lib/public/resource_struct_builder.rb#153
  sig { params(value: T.untyped).returns(T.untyped) }
  def build_generic(value); end

  # source://resource_registry//lib/public/resource_struct_builder.rb#159
  sig { params(value: T.untyped).returns(T.untyped) }
  def build_other(value); end

  # source://resource_registry//lib/public/resource_struct_builder.rb#116
  sig { params(args: T::Hash[T.untyped, T.untyped]).returns(::T::Struct) }
  def build_struct(args); end

  # source://resource_registry//lib/public/resource_struct_builder.rb#130
  sig { params(key: ::Symbol, value: T.untyped).returns(T.nilable([::Symbol, T.untyped])) }
  def build_struct_property(key, value); end

  # source://resource_registry//lib/public/resource_struct_builder.rb#48
  sig { returns(T::Boolean) }
  def generic?; end

  # source://resource_registry//lib/public/resource_struct_builder.rb#96
  sig { params(outer_type: T.untyped).returns(T.untyped) }
  def inner_type(outer_type); end

  # source://resource_registry//lib/public/resource_struct_builder.rb#166
  sig { returns(T.untyped) }
  def resource_type; end

  # source://resource_registry//lib/public/resource_struct_builder.rb#73
  sig { returns(T::Boolean) }
  def set?; end

  # source://resource_registry//lib/public/resource_struct_builder.rb#53
  sig { returns(T::Boolean) }
  def struct?; end

  # source://resource_registry//lib/public/resource_struct_builder.rb#85
  sig { returns(T.untyped) }
  def type; end
end

# source://resource_registry//lib/public/resource_struct_builder.rb#16
class ResourceRegistry::ResourceStructBuilder::ParseInputError < ::StandardError; end

# source://resource_registry//lib/public/serializer.rb#4
class ResourceRegistry::Serializer
  # Maybe this should be a generic?
  #
  # source://resource_registry//lib/public/serializer.rb#9
  sig { params(resource: ::ResourceRegistry::Resource).void }
  def initialize(resource:); end

  # source://resource_registry//lib/public/serializer.rb#18
  sig { params(entity: ::T::Struct, tags: T::Set[::Symbol]).returns(T::Hash[::Symbol, T.untyped]) }
  def serialize(entity:, tags:); end

  private

  # source://resource_registry//lib/public/serializer.rb#51
  sig { params(property_value: T.untyped).returns(T.untyped) }
  def recursive_serialization(property_value); end

  # source://resource_registry//lib/public/serializer.rb#64
  sig { returns(::SchemaRegistry::Schema) }
  def resource_schema; end
end

# This is the representation of a verb over a resource. Each resource can
# have multiple verbs that should be exposed by its repository
#
# source://resource_registry//lib/public/verb.rb#9
class ResourceRegistry::Verb < ::T::Struct
  const :id, ::Symbol
  const :dto_raw, ::String
  const :summary, T.nilable(::String), default: T.unsafe(nil)
  const :description, T.nilable(::String), default: T.unsafe(nil)
  const :deprecated_on, T.nilable(::Date), default: T.unsafe(nil)
  const :webhook_description, T.nilable(::String), default: T.unsafe(nil)
  const :schema, ::SchemaRegistry::Schema
  const :return_many, T::Boolean, default: T.unsafe(nil)

  # source://resource_registry//lib/public/verb.rb#57
  sig { returns(T::Boolean) }
  def create?; end

  # source://resource_registry//lib/public/verb.rb#30
  sig { returns(T::Boolean) }
  def deprecated?; end

  # source://resource_registry//lib/public/verb.rb#47
  sig { returns(T::Boolean) }
  def destroy?; end

  # source://resource_registry//lib/public/verb.rb#62
  sig { returns(T.class_of(T::Struct)) }
  def dto; end

  # source://resource_registry//lib/public/verb.rb#73
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def dump; end

  # source://resource_registry//lib/public/verb.rb#42
  sig { returns(T::Boolean) }
  def get?; end

  # source://resource_registry//lib/public/verb.rb#37
  sig { returns(T::Boolean) }
  def mutation?; end

  # source://resource_registry//lib/public/verb.rb#24
  sig { returns(::Symbol) }
  def schema_identifier; end

  # source://resource_registry//lib/public/verb.rb#52
  sig { returns(T::Boolean) }
  def update?; end

  class << self
    # source://sorbet-runtime/0.5.11670/lib/types/struct.rb#13
    def inherited(s); end

    # @raise [ArgumentError]
    #
    # source://resource_registry//lib/public/verb.rb#83
    sig { params(spec: T.untyped).returns(::ResourceRegistry::Verb) }
    def load(spec); end
  end
end

# source://resource_registry//lib/public/verb.rb#12
class ResourceRegistry::Verb::DtoClassNotFound < ::StandardError; end

# source://resource_registry//lib/public/versions/version.rb#4
class ResourceRegistry::Versions
  # source://resource_registry//lib/public/versions.rb#9
  sig { params(versions: T::Array[::ResourceRegistry::Versions::Version]).void }
  def initialize(versions:); end

  # source://resource_registry//lib/public/versions.rb#14
  sig { params(name: T.nilable(::String)).returns(T.nilable(::ResourceRegistry::Versions::Version)) }
  def find(name); end

  # source://resource_registry//lib/public/versions.rb#21
  sig { params(name: ::String).returns(::ResourceRegistry::Versions::Version) }
  def find!(name); end

  # source://resource_registry//lib/public/versions.rb#26
  sig { params(name: ::String).returns(T.nilable(::ResourceRegistry::Versions::Version)) }
  def find_next(name); end

  # source://resource_registry//lib/public/versions.rb#43
  sig do
    params(
      from: T.nilable(::String),
      to: T.nilable(::String)
    ).returns(T::Array[::ResourceRegistry::Versions::Version])
  end
  def in_range(from, to); end

  # source://resource_registry//lib/public/versions.rb#34
  sig { returns(T::Array[::ResourceRegistry::Versions::Version]) }
  def sorted_versions; end

  private

  # source://resource_registry//lib/public/versions.rb#54
  sig { returns(T::Array[::ResourceRegistry::Versions::Version]) }
  def versions; end
end

# source://resource_registry//lib/public/versions/version.rb#5
class ResourceRegistry::Versions::Version
  # source://resource_registry//lib/public/versions/version.rb#14
  sig { params(name: ::String, aliases: T.nilable(T.any(::String, T::Array[::String]))).void }
  def initialize(name, aliases: T.unsafe(nil)); end

  # source://resource_registry//lib/public/versions/version.rb#46
  sig { params(other: ::ResourceRegistry::Versions::Version).returns(T::Boolean) }
  def <=(other); end

  # source://resource_registry//lib/public/versions/version.rb#36
  sig { params(other: ::ResourceRegistry::Versions::Version).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://resource_registry//lib/public/versions/version.rb#41
  sig { params(other: ::ResourceRegistry::Versions::Version).returns(T::Boolean) }
  def >=(other); end

  # source://resource_registry//lib/public/versions/version.rb#23
  sig { returns(T::Array[::String]) }
  def aliases; end

  # source://resource_registry//lib/public/versions/version.rb#31
  sig { params(str: ::String).returns(T::Boolean) }
  def matches?(str); end

  # source://resource_registry//lib/public/versions/version.rb#20
  sig { returns(::String) }
  def name; end

  # source://resource_registry//lib/public/versions/version.rb#26
  sig { returns(::String) }
  def to_s; end
end

# This module allows using type introspection to serialize/deserialize custom generics in
# T::Structs.
#
# While Sorbet can answer questions about types in T::Structs and arrays, it erases generic types
# at runtime. To support custom generics, we must manually preserve the type information with
# which they were declared.
#
# Use this module instead of `T::Generic` to create generic types with runtime type information.
#
# source://resource_registry//lib/runtime_generic.rb#11
module RuntimeGeneric
  include ::Kernel

  # source://resource_registry//lib/runtime_generic.rb#42
  def [](inner_type); end

  # source://resource_registry//lib/runtime_generic.rb#46
  def type_member(variance = T.unsafe(nil), &blk); end
end

# source://resource_registry//lib/runtime_generic.rb#31
class RuntimeGeneric::MyTypeMember < ::T::Types::TypeMember
  # @return [MyTypeMember] a new instance of MyTypeMember
  #
  # source://resource_registry//lib/runtime_generic.rb#32
  def initialize(variance, &type_proc); end

  # source://resource_registry//lib/runtime_generic.rb#37
  def inner_type; end
end

# source://resource_registry//lib/runtime_generic.rb#16
class RuntimeGeneric::TypedGeneric < ::T::Types::Simple
  # @return [TypedGeneric] a new instance of TypedGeneric
  #
  # source://resource_registry//lib/runtime_generic.rb#23
  def initialize(raw_type, inner_type); end

  # Returns the value of attribute inner_type.
  #
  # source://resource_registry//lib/runtime_generic.rb#28
  def inner_type; end

  # source://resource_registry//lib/runtime_generic.rb#19
  def name; end
end

# source://resource_registry//lib/schema_registry/property_type.rb#3
module SchemaRegistry; end

# source://resource_registry//lib/schema_registry/filter_field.rb#4
class SchemaRegistry::FilterField < ::T::Struct
  const :name, ::String
  const :resolver, T.nilable(T::Hash[::Symbol, ::String])
  const :type, ::SchemaRegistry::PropertyType
  const :in_memory, T::Boolean, default: T.unsafe(nil)

  class << self
    # source://sorbet-runtime/0.5.11670/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://resource_registry//lib/schema_registry/generate_from_struct.rb#4
class SchemaRegistry::GenerateFromStruct
  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#16
  sig { params(struct_klass: T.class_of(T::Struct)).void }
  def initialize(struct_klass:); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#21
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def call; end

  private

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#81
  sig { params(klass: T.untyped).returns(T.nilable(T::Array[::String])) }
  def calculate_required(klass); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#144
  sig { params(typedef: T.untyped).returns(T::Boolean) }
  def can_resolve_type?(typedef); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#154
  sig do
    params(
      prop: T.untyped
    ).returns(T.nilable(T.any(::BigDecimal, ::Date, ::DateTime, ::Float, ::Integer, ::ResourceRegistry::Versions::Version, ::String, ::Time, Maybe[T.untyped], T::Array[T.untyped], T::Boolean, T::Hash[::String, T.untyped])))
  end
  def compute_default(prop); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#99
  sig { params(typedef: T.untyped, prop: T.untyped).returns(T::Hash[T.untyped, T.untyped]) }
  def deep_generate_array(typedef, prop); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#122
  sig do
    params(
      array_type: T.any(::String, T::Array[::String]),
      typedef: T.untyped
    ).returns(T::Hash[T.untyped, T.untyped])
  end
  def deep_generate_items(array_type, typedef); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#42
  sig { params(klass: T.class_of(T::Struct)).returns(T::Hash[::Symbol, T.untyped]) }
  def deep_generate_properties(klass); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#212
  sig { params(type: T.untyped).returns(T::Boolean) }
  def enum?(type); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#197
  sig do
    params(
      type: T.any(::Integer, ::T::Types::Union, T.untyped),
      type_object: T.untyped
    ).returns(T::Array[::String])
  end
  def nilable_sorbet_type_to_json(type:, type_object: T.unsafe(nil)); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#204
  sig { params(type: T.untyped).returns(T::Boolean) }
  def represented_as_string?(type); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#89
  sig { params(definition: T.untyped).returns(T::Boolean) }
  def required?(definition); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#175
  sig do
    params(
      type: T.any(::Integer, ::T::Types::Union, T.untyped),
      type_object: T.untyped,
      nilable: T::Boolean
    ).returns(T.any(::String, T::Array[::String]))
  end
  def sorbet_type_to_json(type:, type_object: T.unsafe(nil), nilable: T.unsafe(nil)); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#218
  sig { params(type: T.untyped).returns(T.nilable(::String)) }
  def sorbet_type_to_json_format(type:); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#37
  sig { returns(T.class_of(T::Struct)) }
  def struct_klass; end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#230
  sig { params(definition: T.untyped, type_object: T.untyped).returns(T.untyped) }
  def type_definition(definition, type_object); end

  # source://resource_registry//lib/schema_registry/generate_from_struct.rb#244
  sig { params(type: T.untyped).returns(T.untyped) }
  def union_type_definition(type); end
end

# source://resource_registry//lib/schema_registry/generate_from_struct.rb#7
class SchemaRegistry::GenerateFromStruct::SolvableNestedTypes < ::T::Enum
  enums do
    Dtos = new
    Entities = new
    ValueObjects = new
  end
end

# source://resource_registry//lib/schema_registry/json_schema_mapper.rb#4
class SchemaRegistry::JsonSchemaMapper
  # TODO: Proper type json-schema
  #
  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#14
  sig { params(namespace: ::String, definition: T.untyped).void }
  def initialize(namespace:, definition:); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#20
  sig { returns(::SchemaRegistry::Schema) }
  def call; end

  private

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#42
  sig { returns(T.untyped) }
  def definition; end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#77
  sig do
    params(
      input: T.nilable(T::Array[T::Hash[::String, T.untyped]])
    ).returns(T::Array[::SchemaRegistry::FilterField])
  end
  def handle_fields(input); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#52
  sig { params(items: T.nilable(T::Hash[T.untyped, T.untyped])).returns(T::Array[::SchemaRegistry::Property]) }
  def handle_items(items); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#96
  sig do
    params(
      properties: T.nilable(T::Hash[T.untyped, T.untyped]),
      required: T.nilable(T::Array[::String])
    ).returns(T.nilable(T::Array[::SchemaRegistry::Property]))
  end
  def handle_properties(properties, required); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#161
  sig do
    params(
      resolver: T.nilable(T.any(::String, T::Hash[::Symbol, ::String]))
    ).returns(T.nilable(T::Hash[::Symbol, ::String]))
  end
  def handle_resolver(resolver); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#174
  sig { params(serialization_groups: T.nilable(T::Array[::String])).returns(T::Set[::Symbol]) }
  def handle_serialization_groups(serialization_groups); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#143
  sig do
    params(
      prop_type: T.any(::String, T::Array[::String]),
      format: T.nilable(::String)
    ).returns(T::Array[::SchemaRegistry::PropertyType])
  end
  def handle_types(prop_type, format); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#45
  sig { returns(::String) }
  def namespace; end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#150
  sig { params(prop_type: T.any(::String, T::Array[::String])).returns(T::Boolean) }
  def nilable?(prop_type); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#213
  sig { params(format: T.nilable(::String)).returns(::SchemaRegistry::PropertyType) }
  def string_format_to_sorbet(format); end

  # source://resource_registry//lib/schema_registry/json_schema_mapper.rb#186
  sig do
    params(
      json_schema_type: T.nilable(::String),
      format: T.nilable(::String)
    ).returns(::SchemaRegistry::PropertyType)
  end
  def type_to_sorbet(json_schema_type, format); end
end

# source://resource_registry//lib/schema_registry/json_schema_mapper.rb#10
SchemaRegistry::JsonSchemaMapper::DATE_FIELDS = T.let(T.unsafe(nil), Array)

# source://resource_registry//lib/schema_registry/json_schema_mapper.rb#7
class SchemaRegistry::JsonSchemaMapper::UnrecognizedJsonSchemaTypeError < ::StandardError; end

# source://resource_registry//lib/schema_registry/property.rb#11
class SchemaRegistry::Property < ::T::Struct
  const :name, ::String
  const :types, T::Array[::SchemaRegistry::PropertyType]
  const :type_name, T.nilable(::String)
  const :items, T::Array[::SchemaRegistry::Property], default: T.unsafe(nil)
  const :properties, T::Array[::SchemaRegistry::Property], default: T.unsafe(nil)
  const :description, T.nilable(::String), default: T.unsafe(nil)
  const :resolver, T.nilable(T::Hash[::Symbol, ::String]), default: T.unsafe(nil)
  const :resolvable, T::Boolean, default: T.unsafe(nil)
  const :deprecated, T::Boolean, default: T.unsafe(nil)
  const :deprecated_on, T.nilable(::Date), default: T.unsafe(nil)
  const :example, T.nilable(T.any(::BigDecimal, ::Date, ::DateTime, ::Float, ::Integer, ::ResourceRegistry::Versions::Version, ::String, ::Time, Maybe[T.untyped], T::Array[T.untyped], T::Boolean, T::Hash[::String, T.untyped])), default: T.unsafe(nil)
  const :enum_values, T.nilable(T::Array[::String]), default: T.unsafe(nil)
  const :required, T::Boolean
  const :default, T.nilable(T.any(::BigDecimal, ::Date, ::DateTime, ::Float, ::Integer, ::ResourceRegistry::Versions::Version, ::String, ::Time, Maybe[T.untyped], T::Array[T.untyped], T::Boolean, T::Hash[::String, T.untyped])), default: T.unsafe(nil)
  const :serialization_groups, T::Set[::Symbol], default: T.unsafe(nil)

  # source://resource_registry//lib/schema_registry/property.rb#51
  sig { returns(T::Boolean) }
  def deprecated?; end

  # source://resource_registry//lib/schema_registry/property.rb#70
  sig { returns(T::Boolean) }
  def nilable?; end

  # source://resource_registry//lib/schema_registry/property.rb#58
  sig { returns(T::Boolean) }
  def null?; end

  # source://resource_registry//lib/schema_registry/property.rb#77
  sig { returns(T::Boolean) }
  def required?; end

  # source://resource_registry//lib/schema_registry/property.rb#87
  sig { params(group: ::Symbol).returns(T::Boolean) }
  def serialization_group?(group); end

  # source://resource_registry//lib/schema_registry/property.rb#82
  sig { returns(T::Boolean) }
  def value_object?; end

  class << self
    # source://sorbet-runtime/0.5.11670/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://resource_registry//lib/schema_registry/property.rb#14
SchemaRegistry::Property::ValueType = T.type_alias { T.nilable(T.any(::BigDecimal, ::Date, ::DateTime, ::Float, ::Integer, ::ResourceRegistry::Versions::Version, ::String, ::Time, Maybe[T.untyped], T::Array[T.untyped], T::Boolean, T::Hash[::String, T.untyped])) }

# source://resource_registry//lib/schema_registry/property_mapper.rb#4
class SchemaRegistry::PropertyMapper
  # TODO: Proper type json-schema
  #
  # source://resource_registry//lib/schema_registry/property_mapper.rb#9
  sig { params(schema: ::SchemaRegistry::Schema).void }
  def initialize(schema:); end

  # source://resource_registry//lib/schema_registry/property_mapper.rb#14
  sig { returns(T::Hash[::String, T.untyped]) }
  def call; end

  private

  # source://resource_registry//lib/schema_registry/property_mapper.rb#28
  sig { returns(::SchemaRegistry::Schema) }
  def schema; end

  # source://resource_registry//lib/schema_registry/property_mapper.rb#31
  sig { params(property: ::SchemaRegistry::Property).returns(T.untyped) }
  def sorbet_to_json_schema(property); end
end

# source://resource_registry//lib/schema_registry/property_type.rb#6
class SchemaRegistry::PropertyType < ::T::Enum
  enums do
    String = new
    Number = new
    Integer = new
    BigInteger = new
    Object = new
    Array = new
    Boolean = new
    Null = new
    DateTime = new
    Time = new
    Date = new
    Duration = new
    Email = new
    Uri = new
    Regex = new
    File = new
  end

  # source://resource_registry//lib/schema_registry/property_type.rb#35
  sig { returns(T.nilable(::String)) }
  def sorbet_type; end
end

# source://resource_registry//lib/schema_registry/registry.rb#4
class SchemaRegistry::Registry
  # source://resource_registry//lib/schema_registry/registry.rb#10
  sig { void }
  def initialize; end

  # source://resource_registry//lib/schema_registry/registry.rb#45
  sig { returns(::SchemaRegistry::Registry) }
  def cleanup; end

  # source://resource_registry//lib/schema_registry/registry.rb#35
  sig { params(identifier: ::Symbol).returns(T.nilable(::SchemaRegistry::Schema)) }
  def fetch(identifier); end

  # source://resource_registry//lib/schema_registry/registry.rb#24
  sig { params(identifier: ::Symbol).returns(T.nilable(::SchemaRegistry::Schema)) }
  def fetch!(identifier); end

  # source://resource_registry//lib/schema_registry/registry.rb#40
  sig { returns(T::Hash[::Symbol, ::SchemaRegistry::Schema]) }
  def fetch_all; end

  # source://resource_registry//lib/schema_registry/registry.rb#15
  sig { params(schema: ::SchemaRegistry::Schema).returns(::SchemaRegistry::Registry) }
  def register(schema); end
end

# source://resource_registry//lib/schema_registry/registry.rb#7
class SchemaRegistry::Registry::SchemaNotFound < ::StandardError; end

# source://resource_registry//lib/schema_registry/schema.rb#9
class SchemaRegistry::Schema < ::T::Struct
  const :name, ::String
  const :namespace, ::String
  const :properties, T::Array[::SchemaRegistry::Property]
  const :raw_json_schema, T::Hash[::String, T.untyped], default: T.unsafe(nil)
  const :additional_filter_fields, T::Array[::SchemaRegistry::FilterField], default: T.unsafe(nil)

  # source://resource_registry//lib/schema_registry/schema.rb#78
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def dump; end

  # source://resource_registry//lib/schema_registry/schema.rb#44
  sig { params(name: ::String).returns(T.nilable(::SchemaRegistry::FilterField)) }
  def find_additional_filter_field(name); end

  # source://resource_registry//lib/schema_registry/schema.rb#39
  sig { params(name: ::String).returns(T.nilable(::SchemaRegistry::Property)) }
  def find_property(name); end

  # source://resource_registry//lib/schema_registry/schema.rb#59
  sig { params(name: ::String).returns(T.nilable(T::Hash[::Symbol, ::String])) }
  def get_resolver(name); end

  # source://resource_registry//lib/schema_registry/schema.rb#49
  sig { params(name: ::String).returns(T::Boolean) }
  def has_property?(name); end

  # source://resource_registry//lib/schema_registry/schema.rb#29
  sig { returns(::Symbol) }
  def identifier; end

  # source://resource_registry//lib/schema_registry/schema.rb#54
  sig { returns(::String) }
  def namespace_with_slug; end

  # source://resource_registry//lib/schema_registry/schema.rb#19
  sig { returns(::String) }
  def schema_module_name; end

  # source://resource_registry//lib/schema_registry/schema.rb#24
  sig { returns(::String) }
  def slug; end

  class << self
    # source://sorbet-runtime/0.5.11670/lib/types/struct.rb#13
    def inherited(s); end

    # source://resource_registry//lib/schema_registry/schema.rb#86
    sig { params(spec: T.untyped).returns(::SchemaRegistry::Schema) }
    def load(spec); end
  end
end
